/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../utils/ContextUpgradeable.sol";
    | import "../proxy/utils/Initializable.sol";
    | 
    | /**
    |  * @dev Contract module which provides a basic access control mechanism, where
    |  * there is an account (an owner) that can be granted exclusive access to
    |  * specific functions.
    |  *
    |  * By default, the owner account will be the one that deploys the contract. This
    |  * can later be changed with {transferOwnership}.
    |  *
    |  * This module is used through inheritance. It will make available the modifier
    |  * `onlyOwner`, which can be applied to your functions to restrict their use to
    |  * the owner.
    |  */
    | abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {
    |     address private _owner;
    | 
    |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    | 
    |     /**
    |      * @dev Initializes the contract setting the deployer as the initial owner.
    |      */
    |     function __Ownable_init() internal onlyInitializing {
    |         __Ownable_init_unchained();
    |     }
    | 
    |     function __Ownable_init_unchained() internal onlyInitializing {
    |         _transferOwnership(_msgSender());
    |     }
    | 
    |     /**
    |      * @dev Throws if called by any account other than the owner.
    |      */
    |     modifier onlyOwner() {
    |         _checkOwner();
    |         _;
    |     }
    | 
    |     /**
    |      * @dev Returns the address of the current owner.
    |      */
    |     function owner() public view virtual returns (address) {
    |         return _owner;
    |     }
    | 
    |     /**
    |      * @dev Throws if the sender is not the owner.
    |      */
    |     function _checkOwner() internal view virtual {
    |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
    |     }
    | 
    |     /**
    |      * @dev Leaves the contract without owner. It will not be possible to call
    |      * `onlyOwner` functions anymore. Can only be called by the current owner.
    |      *
    |      * NOTE: Renouncing ownership will leave the contract without an owner,
    |      * thereby removing any functionality that is only available to the owner.
    |      */
    |     function renounceOwnership() public virtual onlyOwner {
    |         _transferOwnership(address(0));
    |     }
    | 
    |     /**
    |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
    |      * Can only be called by the current owner.
    |      */
    |     function transferOwnership(address newOwner) public virtual onlyOwner {
    |         require(newOwner != address(0), "Ownable: new owner is the zero address");
    |         _transferOwnership(newOwner);
    |     }
    | 
    |     /**
    |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
    |      * Internal function without access restriction.
    |      */
    |     function _transferOwnership(address newOwner) internal virtual {
    |         address oldOwner = _owner;
    |         _owner = newOwner;
    |         emit OwnershipTransferred(oldOwner, newOwner);
    |     }
    | 
    |     /**
    |      * @dev This empty reserved space is put in place to allow future versions to add new
    |      * variables without shifting down storage in the inheritance chain.
    |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
    |      */
    |     uint256[49] private __gap;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified
    |  * proxy whose upgrades are fully controlled by the current implementation.
    |  */
    | interface IERC1822ProxiableUpgradeable {
    |     /**
    |      * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation
    |      * address.
    |      *
    |      * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks
    |      * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this
    |      * function revert if invoked through a proxy.
    |      */
    |     function proxiableUUID() external view returns (bytes32);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)
    | 
    | pragma solidity ^0.8.2;
    | 
    | import "../beacon/IBeaconUpgradeable.sol";
    | import "../../interfaces/draft-IERC1822Upgradeable.sol";
    | import "../../utils/AddressUpgradeable.sol";
    | import "../../utils/StorageSlotUpgradeable.sol";
    | import "../utils/Initializable.sol";
    | 
    | /**
    |  * @dev This abstract contract provides getters and event emitting update functions for
    |  * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.
    |  *
    |  * _Available since v4.1._
    |  *
    |  * @custom:oz-upgrades-unsafe-allow delegatecall
    |  */
    | abstract contract ERC1967UpgradeUpgradeable is Initializable {
    |     function __ERC1967Upgrade_init() internal onlyInitializing {
    |     }
    | 
    |     function __ERC1967Upgrade_init_unchained() internal onlyInitializing {
    |     }
    |     // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1
    |     bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;
    | 
    |     /**
    |      * @dev Storage slot with the address of the current implementation.
    |      * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is
    |      * validated in the constructor.
    |      */
    |     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    | 
    |     /**
    |      * @dev Emitted when the implementation is upgraded.
    |      */
    |     event Upgraded(address indexed implementation);
    | 
    |     /**
    |      * @dev Returns the current implementation address.
    |      */
    |     function _getImplementation() internal view returns (address) {
    |         return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;
    |     }
    | 
    |     /**
    |      * @dev Stores a new address in the EIP1967 implementation slot.
    |      */
    |     function _setImplementation(address newImplementation) private {
    |         require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");
    |         StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
    |     }
    | 
    |     /**
    |      * @dev Perform implementation upgrade
    |      *
    |      * Emits an {Upgraded} event.
    |      */
    |     function _upgradeTo(address newImplementation) internal {
    |         _setImplementation(newImplementation);
    |         emit Upgraded(newImplementation);
    |     }
    | 
    |     /**
    |      * @dev Perform implementation upgrade with additional setup call.
    |      *
    |      * Emits an {Upgraded} event.
    |      */
    |     function _upgradeToAndCall(
    |         address newImplementation,
    |         bytes memory data,
    |         bool forceCall
    |     ) internal {
    |         _upgradeTo(newImplementation);
    |         if (data.length > 0 || forceCall) {
    |             _functionDelegateCall(newImplementation, data);
    |         }
    |     }
    | 
    |     /**
    |      * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.
    |      *
    |      * Emits an {Upgraded} event.
    |      */
    |     function _upgradeToAndCallUUPS(
    |         address newImplementation,
    |         bytes memory data,
    |         bool forceCall
    |     ) internal {
    |         // Upgrades from old implementations will perform a rollback test. This test requires the new
    |         // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing
    |         // this special case will break upgrade paths from old UUPS implementation to new ones.
    |         if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {
    |             _setImplementation(newImplementation);
    |         } else {
    |             try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {
    |                 require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");
    |             } catch {
    |                 revert("ERC1967Upgrade: new implementation is not UUPS");
    |             }
    |             _upgradeToAndCall(newImplementation, data, forceCall);
    |         }
    |     }
    | 
    |     /**
    |      * @dev Storage slot with the admin of the contract.
    |      * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is
    |      * validated in the constructor.
    |      */
    |     bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
    | 
    |     /**
    |      * @dev Emitted when the admin account has changed.
    |      */
    |     event AdminChanged(address previousAdmin, address newAdmin);
    | 
    |     /**
    |      * @dev Returns the current admin.
    |      */
    |     function _getAdmin() internal view returns (address) {
    |         return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;
    |     }
    | 
    |     /**
    |      * @dev Stores a new address in the EIP1967 admin slot.
    |      */
    |     function _setAdmin(address newAdmin) private {
    |         require(newAdmin != address(0), "ERC1967: new admin is the zero address");
    |         StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;
    |     }
    | 
    |     /**
    |      * @dev Changes the admin of the proxy.
    |      *
    |      * Emits an {AdminChanged} event.
    |      */
    |     function _changeAdmin(address newAdmin) internal {
    |         emit AdminChanged(_getAdmin(), newAdmin);
    |         _setAdmin(newAdmin);
    |     }
    | 
    |     /**
    |      * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.
    |      * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.
    |      */
    |     bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
    | 
    |     /**
    |      * @dev Emitted when the beacon is upgraded.
    |      */
    |     event BeaconUpgraded(address indexed beacon);
    | 
    |     /**
    |      * @dev Returns the current beacon.
    |      */
    |     function _getBeacon() internal view returns (address) {
    |         return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;
    |     }
    | 
    |     /**
    |      * @dev Stores a new beacon in the EIP1967 beacon slot.
    |      */
    |     function _setBeacon(address newBeacon) private {
    |         require(AddressUpgradeable.isContract(newBeacon), "ERC1967: new beacon is not a contract");
    |         require(
    |             AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),
    |             "ERC1967: beacon implementation is not a contract"
    |         );
    |         StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;
    |     }
    | 
    |     /**
    |      * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does
    |      * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).
    |      *
    |      * Emits a {BeaconUpgraded} event.
    |      */
    |     function _upgradeBeaconToAndCall(
    |         address newBeacon,
    |         bytes memory data,
    |         bool forceCall
    |     ) internal {
    |         _setBeacon(newBeacon);
    |         emit BeaconUpgraded(newBeacon);
    |         if (data.length > 0 || forceCall) {
    |             _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);
    |         }
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
    |      * but performing a delegate call.
    |      *
    |      * _Available since v3.4._
    |      */
    |     function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {
    |         require(AddressUpgradeable.isContract(target), "Address: delegate call to non-contract");
    | 
    |         // solhint-disable-next-line avoid-low-level-calls
    |         (bool success, bytes memory returndata) = target.delegatecall(data);
    |         return AddressUpgradeable.verifyCallResult(success, returndata, "Address: low-level delegate call failed");
    |     }
    | 
    |     /**
    |      * @dev This empty reserved space is put in place to allow future versions to add new
    |      * variables without shifting down storage in the inheritance chain.
    |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
    |      */
    |     uint256[50] private __gap;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev This is the interface that {BeaconProxy} expects of its beacon.
    |  */
    | interface IBeaconUpgradeable {
    |     /**
    |      * @dev Must return an address that can be used as a delegate call target.
    |      *
    |      * {BeaconProxy} will check that this address is a contract.
    |      */
    |     function implementation() external view returns (address);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)
    | 
    | pragma solidity ^0.8.2;
    | 
    | import "../../utils/AddressUpgradeable.sol";
    | 
    | /**
    |  * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
    |  * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
    |  * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
    |  * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
    |  *
    |  * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
    |  * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
    |  * case an upgrade adds a module that needs to be initialized.
    |  *
    |  * For example:
    |  *
    |  * [.hljs-theme-light.nopadding]
    |  * ```
    |  * contract MyToken is ERC20Upgradeable {
    |  *     function initialize() initializer public {
    |  *         __ERC20_init("MyToken", "MTK");
    |  *     }
    |  * }
    |  * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
    |  *     function initializeV2() reinitializer(2) public {
    |  *         __ERC20Permit_init("MyToken");
    |  *     }
    |  * }
    |  * ```
    |  *
    |  * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
    |  * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
    |  *
    |  * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
    |  * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
    |  *
    |  * [CAUTION]
    |  * ====
    |  * Avoid leaving a contract uninitialized.
    |  *
    |  * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
    |  * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
    |  * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
    |  *
    |  * [.hljs-theme-light.nopadding]
    |  * ```
    |  * /// @custom:oz-upgrades-unsafe-allow constructor
    |  * constructor() {
    |  *     _disableInitializers();
    |  * }
    |  * ```
    |  * ====
    |  */
    | abstract contract Initializable {
    |     /**
    |      * @dev Indicates that the contract has been initialized.
    |      * @custom:oz-retyped-from bool
    |      */
    |     uint8 private _initialized;
    | 
    |     /**
    |      * @dev Indicates that the contract is in the process of being initialized.
    |      */
    |     bool private _initializing;
    | 
    |     /**
    |      * @dev Triggered when the contract has been initialized or reinitialized.
    |      */
    |     event Initialized(uint8 version);
    | 
    |     /**
    |      * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
    |      * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.
    |      */
    |     modifier initializer() {
    |         bool isTopLevelCall = !_initializing;
    |         require(
    |             (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),
    |             "Initializable: contract is already initialized"
    |         );
    |         _initialized = 1;
    |         if (isTopLevelCall) {
    |             _initializing = true;
    |         }
    |         _;
    |         if (isTopLevelCall) {
    |             _initializing = false;
    |             emit Initialized(1);
    |         }
    |     }
    | 
    |     /**
    |      * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
    |      * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
    |      * used to initialize parent contracts.
    |      *
    |      * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original
    |      * initialization step. This is essential to configure modules that are added through upgrades and that require
    |      * initialization.
    |      *
    |      * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
    |      * a contract, executing them in the right order is up to the developer or operator.
    |      */
    |     modifier reinitializer(uint8 version) {
    |         require(!_initializing && _initialized < version, "Initializable: contract is already initialized");
    |         _initialized = version;
    |         _initializing = true;
    |         _;
    |         _initializing = false;
    |         emit Initialized(version);
    |     }
    | 
    |     /**
    |      * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
    |      * {initializer} and {reinitializer} modifiers, directly or indirectly.
    |      */
    |     modifier onlyInitializing() {
    |         require(_initializing, "Initializable: contract is not initializing");
    |         _;
    |     }
    | 
    |     /**
    |      * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
    |      * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
    |      * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
    |      * through proxies.
    |      */
    |     function _disableInitializers() internal virtual {
    |         require(!_initializing, "Initializable: contract is initializing");
    |         if (_initialized < type(uint8).max) {
    |             _initialized = type(uint8).max;
    |             emit Initialized(type(uint8).max);
    |         }
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../../interfaces/draft-IERC1822Upgradeable.sol";
    | import "../ERC1967/ERC1967UpgradeUpgradeable.sol";
    | import "./Initializable.sol";
    | 
    | /**
    |  * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an
    |  * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.
    |  *
    |  * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is
    |  * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing
    |  * `UUPSUpgradeable` with a custom implementation of upgrades.
    |  *
    |  * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.
    |  *
    |  * _Available since v4.1._
    |  */
    | abstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {
    |     function __UUPSUpgradeable_init() internal onlyInitializing {
    |     }
    | 
    |     function __UUPSUpgradeable_init_unchained() internal onlyInitializing {
    |     }
    |     /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment
    |     address private immutable __self = address(this);
    | 
    |     /**
    |      * @dev Check that the execution is being performed through a delegatecall call and that the execution context is
    |      * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case
    |      * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a
    |      * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to
    |      * fail.
    |      */
    |     modifier onlyProxy() {
    |         require(address(this) != __self, "Function must be called through delegatecall");
    |         require(_getImplementation() == __self, "Function must be called through active proxy");
    |         _;
    |     }
    | 
    |     /**
    |      * @dev Check that the execution is not being performed through a delegate call. This allows a function to be
    |      * callable on the implementing contract but not through proxies.
    |      */
    |     modifier notDelegated() {
*   |         require(address(this) == __self, "UUPSUpgradeable: must not be called through delegatecall");
    |         _;
    |     }
    | 
    |     /**
    |      * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the
    |      * implementation. It is used to validate that the this implementation remains valid after an upgrade.
    |      *
    |      * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks
    |      * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this
    |      * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.
    |      */
*   |     function proxiableUUID() external view virtual override notDelegated returns (bytes32) {
    |         return _IMPLEMENTATION_SLOT;
    |     }
    | 
    |     /**
    |      * @dev Upgrade the implementation of the proxy to `newImplementation`.
    |      *
    |      * Calls {_authorizeUpgrade}.
    |      *
    |      * Emits an {Upgraded} event.
    |      */
    |     function upgradeTo(address newImplementation) external virtual onlyProxy {
    |         _authorizeUpgrade(newImplementation);
    |         _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);
    |     }
    | 
    |     /**
    |      * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call
    |      * encoded in `data`.
    |      *
    |      * Calls {_authorizeUpgrade}.
    |      *
    |      * Emits an {Upgraded} event.
    |      */
    |     function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {
    |         _authorizeUpgrade(newImplementation);
    |         _upgradeToAndCallUUPS(newImplementation, data, true);
    |     }
    | 
    |     /**
    |      * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by
    |      * {upgradeTo} and {upgradeToAndCall}.
    |      *
    |      * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.
    |      *
    |      * ```solidity
    |      * function _authorizeUpgrade(address) internal override onlyOwner {}
    |      * ```
    |      */
    |     function _authorizeUpgrade(address newImplementation) internal virtual;
    | 
    |     /**
    |      * @dev This empty reserved space is put in place to allow future versions to add new
    |      * variables without shifting down storage in the inheritance chain.
    |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
    |      */
    |     uint256[50] private __gap;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)
    | 
    | pragma solidity ^0.8.0;
    | import "../proxy/utils/Initializable.sol";
    | 
    | /**
    |  * @dev Contract module that helps prevent reentrant calls to a function.
    |  *
    |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
    |  * available, which can be applied to functions to make sure there are no nested
    |  * (reentrant) calls to them.
    |  *
    |  * Note that because there is a single `nonReentrant` guard, functions marked as
    |  * `nonReentrant` may not call one another. This can be worked around by making
    |  * those functions `private`, and then adding `external` `nonReentrant` entry
    |  * points to them.
    |  *
    |  * TIP: If you would like to learn more about reentrancy and alternative ways
    |  * to protect against it, check out our blog post
    |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
    |  */
    | abstract contract ReentrancyGuardUpgradeable is Initializable {
    |     // Booleans are more expensive than uint256 or any type that takes up a full
    |     // word because each write operation emits an extra SLOAD to first read the
    |     // slot's contents, replace the bits taken up by the boolean, and then write
    |     // back. This is the compiler's defense against contract upgrades and
    |     // pointer aliasing, and it cannot be disabled.
    | 
    |     // The values being non-zero value makes deployment a bit more expensive,
    |     // but in exchange the refund on every call to nonReentrant will be lower in
    |     // amount. Since refunds are capped to a percentage of the total
    |     // transaction's gas, it is best to keep them low in cases like this one, to
    |     // increase the likelihood of the full refund coming into effect.
    |     uint256 private constant _NOT_ENTERED = 1;
    |     uint256 private constant _ENTERED = 2;
    | 
    |     uint256 private _status;
    | 
    |     function __ReentrancyGuard_init() internal onlyInitializing {
    |         __ReentrancyGuard_init_unchained();
    |     }
    | 
    |     function __ReentrancyGuard_init_unchained() internal onlyInitializing {
    |         _status = _NOT_ENTERED;
    |     }
    | 
    |     /**
    |      * @dev Prevents a contract from calling itself, directly or indirectly.
    |      * Calling a `nonReentrant` function from another `nonReentrant`
    |      * function is not supported. It is possible to prevent this from happening
    |      * by making the `nonReentrant` function external, and making it call a
    |      * `private` function that does the actual work.
    |      */
    |     modifier nonReentrant() {
    |         // On the first call to nonReentrant, _notEntered will be true
    |         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
    | 
    |         // Any calls to nonReentrant after this point will fail
    |         _status = _ENTERED;
    | 
    |         _;
    | 
    |         // By storing the original value once again, a refund is triggered (see
    |         // https://eips.ethereum.org/EIPS/eip-2200)
    |         _status = _NOT_ENTERED;
    |     }
    | 
    |     /**
    |      * @dev This empty reserved space is put in place to allow future versions to add new
    |      * variables without shifting down storage in the inheritance chain.
    |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
    |      */
    |     uint256[49] private __gap;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Interface of the ERC20 standard as defined in the EIP.
    |  */
    | interface IERC20Upgradeable {
    |     /**
    |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
    |      * another (`to`).
    |      *
    |      * Note that `value` may be zero.
    |      */
    |     event Transfer(address indexed from, address indexed to, uint256 value);
    | 
    |     /**
    |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
    |      * a call to {approve}. `value` is the new allowance.
    |      */
    |     event Approval(address indexed owner, address indexed spender, uint256 value);
    | 
    |     /**
    |      * @dev Returns the amount of tokens in existence.
    |      */
    |     function totalSupply() external view returns (uint256);
    | 
    |     /**
    |      * @dev Returns the amount of tokens owned by `account`.
    |      */
    |     function balanceOf(address account) external view returns (uint256);
    | 
    |     /**
    |      * @dev Moves `amount` tokens from the caller's account to `to`.
    |      *
    |      * Returns a boolean value indicating whether the operation succeeded.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function transfer(address to, uint256 amount) external returns (bool);
    | 
    |     /**
    |      * @dev Returns the remaining number of tokens that `spender` will be
    |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
    |      * zero by default.
    |      *
    |      * This value changes when {approve} or {transferFrom} are called.
    |      */
    |     function allowance(address owner, address spender) external view returns (uint256);
    | 
    |     /**
    |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
    |      *
    |      * Returns a boolean value indicating whether the operation succeeded.
    |      *
    |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
    |      * that someone may use both the old and the new allowance by unfortunate
    |      * transaction ordering. One possible solution to mitigate this race
    |      * condition is to first reduce the spender's allowance to 0 and set the
    |      * desired value afterwards:
    |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    |      *
    |      * Emits an {Approval} event.
    |      */
    |     function approve(address spender, uint256 amount) external returns (bool);
    | 
    |     /**
    |      * @dev Moves `amount` tokens from `from` to `to` using the
    |      * allowance mechanism. `amount` is then deducted from the caller's
    |      * allowance.
    |      *
    |      * Returns a boolean value indicating whether the operation succeeded.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function transferFrom(
    |         address from,
    |         address to,
    |         uint256 amount
    |     ) external returns (bool);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
    |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
    |  *
    |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
    |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
    |  * need to send a transaction, and thus is not required to hold Ether at all.
    |  */
    | interface IERC20PermitUpgradeable {
    |     /**
    |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
    |      * given ``owner``'s signed approval.
    |      *
    |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
    |      * ordering also apply here.
    |      *
    |      * Emits an {Approval} event.
    |      *
    |      * Requirements:
    |      *
    |      * - `spender` cannot be the zero address.
    |      * - `deadline` must be a timestamp in the future.
    |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
    |      * over the EIP712-formatted function arguments.
    |      * - the signature must use ``owner``'s current nonce (see {nonces}).
    |      *
    |      * For more information on the signature format, see the
    |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
    |      * section].
    |      */
    |     function permit(
    |         address owner,
    |         address spender,
    |         uint256 value,
    |         uint256 deadline,
    |         uint8 v,
    |         bytes32 r,
    |         bytes32 s
    |     ) external;
    | 
    |     /**
    |      * @dev Returns the current nonce for `owner`. This value must be
    |      * included whenever a signature is generated for {permit}.
    |      *
    |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
    |      * prevents a signature from being used multiple times.
    |      */
    |     function nonces(address owner) external view returns (uint256);
    | 
    |     /**
    |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
    |      */
    |     // solhint-disable-next-line func-name-mixedcase
    |     function DOMAIN_SEPARATOR() external view returns (bytes32);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../IERC20Upgradeable.sol";
    | import "../extensions/draft-IERC20PermitUpgradeable.sol";
    | import "../../../utils/AddressUpgradeable.sol";
    | 
    | /**
    |  * @title SafeERC20
    |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
    |  * contract returns false). Tokens that return no value (and instead revert or
    |  * throw on failure) are also supported, non-reverting calls are assumed to be
    |  * successful.
    |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
    |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
    |  */
    | library SafeERC20Upgradeable {
    |     using AddressUpgradeable for address;
    | 
    |     function safeTransfer(
    |         IERC20Upgradeable token,
    |         address to,
    |         uint256 value
    |     ) internal {
    |         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    |     }
    | 
    |     function safeTransferFrom(
    |         IERC20Upgradeable token,
    |         address from,
    |         address to,
    |         uint256 value
    |     ) internal {
    |         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    |     }
    | 
    |     /**
    |      * @dev Deprecated. This function has issues similar to the ones found in
    |      * {IERC20-approve}, and its usage is discouraged.
    |      *
    |      * Whenever possible, use {safeIncreaseAllowance} and
    |      * {safeDecreaseAllowance} instead.
    |      */
    |     function safeApprove(
    |         IERC20Upgradeable token,
    |         address spender,
    |         uint256 value
    |     ) internal {
    |         // safeApprove should only be called when setting an initial allowance,
    |         // or when resetting it to zero. To increase and decrease it, use
    |         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
    |         require(
    |             (value == 0) || (token.allowance(address(this), spender) == 0),
    |             "SafeERC20: approve from non-zero to non-zero allowance"
    |         );
    |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    |     }
    | 
    |     function safeIncreaseAllowance(
    |         IERC20Upgradeable token,
    |         address spender,
    |         uint256 value
    |     ) internal {
    |         uint256 newAllowance = token.allowance(address(this), spender) + value;
    |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    |     }
    | 
    |     function safeDecreaseAllowance(
    |         IERC20Upgradeable token,
    |         address spender,
    |         uint256 value
    |     ) internal {
    |         unchecked {
    |             uint256 oldAllowance = token.allowance(address(this), spender);
    |             require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
    |             uint256 newAllowance = oldAllowance - value;
    |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    |         }
    |     }
    | 
    |     function safePermit(
    |         IERC20PermitUpgradeable token,
    |         address owner,
    |         address spender,
    |         uint256 value,
    |         uint256 deadline,
    |         uint8 v,
    |         bytes32 r,
    |         bytes32 s
    |     ) internal {
    |         uint256 nonceBefore = token.nonces(owner);
    |         token.permit(owner, spender, value, deadline, v, r, s);
    |         uint256 nonceAfter = token.nonces(owner);
    |         require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    |     }
    | 
    |     /**
    |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
    |      * on the return value: the return value is optional (but if data is returned, it must not be false).
    |      * @param token The token targeted by the call.
    |      * @param data The call data (encoded using abi.encode or one of its variants).
    |      */
    |     function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {
    |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
    |         // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that
    |         // the target address contains contract code and also asserts for success in the low-level call.
    | 
    |         bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
    |         if (returndata.length > 0) {
    |             // Return data is optional
    |             require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
    |         }
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @title ERC721 token receiver interface
    |  * @dev Interface for any contract that wants to support safeTransfers
    |  * from ERC721 asset contracts.
    |  */
    | interface IERC721ReceiverUpgradeable {
    |     /**
    |      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
    |      * by `operator` from `from`, this function is called.
    |      *
    |      * It must return its Solidity selector to confirm the token transfer.
    |      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
    |      *
    |      * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
    |      */
    |     function onERC721Received(
    |         address operator,
    |         address from,
    |         uint256 tokenId,
    |         bytes calldata data
    |     ) external returns (bytes4);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../../utils/introspection/IERC165Upgradeable.sol";
    | 
    | /**
    |  * @dev Required interface of an ERC721 compliant contract.
    |  */
    | interface IERC721Upgradeable is IERC165Upgradeable {
    |     /**
    |      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
    |      */
    |     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    | 
    |     /**
    |      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
    |      */
    |     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    | 
    |     /**
    |      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
    |      */
    |     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    | 
    |     /**
    |      * @dev Returns the number of tokens in ``owner``'s account.
    |      */
    |     function balanceOf(address owner) external view returns (uint256 balance);
    | 
    |     /**
    |      * @dev Returns the owner of the `tokenId` token.
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must exist.
    |      */
    |     function ownerOf(uint256 tokenId) external view returns (address owner);
    | 
    |     /**
    |      * @dev Safely transfers `tokenId` token from `from` to `to`.
    |      *
    |      * Requirements:
    |      *
    |      * - `from` cannot be the zero address.
    |      * - `to` cannot be the zero address.
    |      * - `tokenId` token must exist and be owned by `from`.
    |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
    |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function safeTransferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId,
    |         bytes calldata data
    |     ) external;
    | 
    |     /**
    |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
    |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
    |      *
    |      * Requirements:
    |      *
    |      * - `from` cannot be the zero address.
    |      * - `to` cannot be the zero address.
    |      * - `tokenId` token must exist and be owned by `from`.
    |      * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
    |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function safeTransferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) external;
    | 
    |     /**
    |      * @dev Transfers `tokenId` token from `from` to `to`.
    |      *
    |      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
    |      *
    |      * Requirements:
    |      *
    |      * - `from` cannot be the zero address.
    |      * - `to` cannot be the zero address.
    |      * - `tokenId` token must be owned by `from`.
    |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function transferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) external;
    | 
    |     /**
    |      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
    |      * The approval is cleared when the token is transferred.
    |      *
    |      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
    |      *
    |      * Requirements:
    |      *
    |      * - The caller must own the token or be an approved operator.
    |      * - `tokenId` must exist.
    |      *
    |      * Emits an {Approval} event.
    |      */
    |     function approve(address to, uint256 tokenId) external;
    | 
    |     /**
    |      * @dev Approve or remove `operator` as an operator for the caller.
    |      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
    |      *
    |      * Requirements:
    |      *
    |      * - The `operator` cannot be the caller.
    |      *
    |      * Emits an {ApprovalForAll} event.
    |      */
    |     function setApprovalForAll(address operator, bool _approved) external;
    | 
    |     /**
    |      * @dev Returns the account approved for `tokenId` token.
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must exist.
    |      */
    |     function getApproved(uint256 tokenId) external view returns (address operator);
    | 
    |     /**
    |      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
    |      *
    |      * See {setApprovalForAll}
    |      */
    |     function isApprovedForAll(address owner, address operator) external view returns (bool);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts v4.4.1 (token/ERC721/utils/ERC721Holder.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../IERC721ReceiverUpgradeable.sol";
    | import "../../../proxy/utils/Initializable.sol";
    | 
    | /**
    |  * @dev Implementation of the {IERC721Receiver} interface.
    |  *
    |  * Accepts all token transfers.
    |  * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.
    |  */
    | contract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {
    |     function __ERC721Holder_init() internal onlyInitializing {
    |     }
    | 
    |     function __ERC721Holder_init_unchained() internal onlyInitializing {
    |     }
    |     /**
    |      * @dev See {IERC721Receiver-onERC721Received}.
    |      *
    |      * Always returns `IERC721Receiver.onERC721Received.selector`.
    |      */
    |     function onERC721Received(
    |         address,
    |         address,
    |         uint256,
    |         bytes memory
    |     ) public virtual override returns (bytes4) {
    |         return this.onERC721Received.selector;
    |     }
    | 
    |     /**
    |      * @dev This empty reserved space is put in place to allow future versions to add new
    |      * variables without shifting down storage in the inheritance chain.
    |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
    |      */
    |     uint256[50] private __gap;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)
    | 
    | pragma solidity ^0.8.1;
    | 
    | /**
    |  * @dev Collection of functions related to the address type
    |  */
    | library AddressUpgradeable {
    |     /**
    |      * @dev Returns true if `account` is a contract.
    |      *
    |      * [IMPORTANT]
    |      * ====
    |      * It is unsafe to assume that an address for which this function returns
    |      * false is an externally-owned account (EOA) and not a contract.
    |      *
    |      * Among others, `isContract` will return false for the following
    |      * types of addresses:
    |      *
    |      *  - an externally-owned account
    |      *  - a contract in construction
    |      *  - an address where a contract will be created
    |      *  - an address where a contract lived, but was destroyed
    |      * ====
    |      *
    |      * [IMPORTANT]
    |      * ====
    |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
    |      *
    |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
    |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
    |      * constructor.
    |      * ====
    |      */
    |     function isContract(address account) internal view returns (bool) {
    |         // This method relies on extcodesize/address.code.length, which returns 0
    |         // for contracts in construction, since the code is only stored at the end
    |         // of the constructor execution.
    | 
    |         return account.code.length > 0;
    |     }
    | 
    |     /**
    |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
    |      * `recipient`, forwarding all available gas and reverting on errors.
    |      *
    |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
    |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
    |      * imposed by `transfer`, making them unable to receive funds via
    |      * `transfer`. {sendValue} removes this limitation.
    |      *
    |      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
    |      *
    |      * IMPORTANT: because control is transferred to `recipient`, care must be
    |      * taken to not create reentrancy vulnerabilities. Consider using
    |      * {ReentrancyGuard} or the
    |      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
    |      */
    |     function sendValue(address payable recipient, uint256 amount) internal {
    |         require(address(this).balance >= amount, "Address: insufficient balance");
    | 
    |         (bool success, ) = recipient.call{value: amount}("");
    |         require(success, "Address: unable to send value, recipient may have reverted");
    |     }
    | 
    |     /**
    |      * @dev Performs a Solidity function call using a low level `call`. A
    |      * plain `call` is an unsafe replacement for a function call: use this
    |      * function instead.
    |      *
    |      * If `target` reverts with a revert reason, it is bubbled up by this
    |      * function (like regular Solidity function calls).
    |      *
    |      * Returns the raw returned data. To convert to the expected return value,
    |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
    |      *
    |      * Requirements:
    |      *
    |      * - `target` must be a contract.
    |      * - calling `target` with `data` must not revert.
    |      *
    |      * _Available since v3.1._
    |      */
    |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
    |         return functionCall(target, data, "Address: low-level call failed");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
    |      * `errorMessage` as a fallback revert reason when `target` reverts.
    |      *
    |      * _Available since v3.1._
    |      */
    |     function functionCall(
    |         address target,
    |         bytes memory data,
    |         string memory errorMessage
    |     ) internal returns (bytes memory) {
    |         return functionCallWithValue(target, data, 0, errorMessage);
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
    |      * but also transferring `value` wei to `target`.
    |      *
    |      * Requirements:
    |      *
    |      * - the calling contract must have an ETH balance of at least `value`.
    |      * - the called Solidity function must be `payable`.
    |      *
    |      * _Available since v3.1._
    |      */
    |     function functionCallWithValue(
    |         address target,
    |         bytes memory data,
    |         uint256 value
    |     ) internal returns (bytes memory) {
    |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
    |      * with `errorMessage` as a fallback revert reason when `target` reverts.
    |      *
    |      * _Available since v3.1._
    |      */
    |     function functionCallWithValue(
    |         address target,
    |         bytes memory data,
    |         uint256 value,
    |         string memory errorMessage
    |     ) internal returns (bytes memory) {
    |         require(address(this).balance >= value, "Address: insufficient balance for call");
    |         require(isContract(target), "Address: call to non-contract");
    | 
    |         (bool success, bytes memory returndata) = target.call{value: value}(data);
    |         return verifyCallResult(success, returndata, errorMessage);
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
    |      * but performing a static call.
    |      *
    |      * _Available since v3.3._
    |      */
    |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
    |         return functionStaticCall(target, data, "Address: low-level static call failed");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
    |      * but performing a static call.
    |      *
    |      * _Available since v3.3._
    |      */
    |     function functionStaticCall(
    |         address target,
    |         bytes memory data,
    |         string memory errorMessage
    |     ) internal view returns (bytes memory) {
    |         require(isContract(target), "Address: static call to non-contract");
    | 
    |         (bool success, bytes memory returndata) = target.staticcall(data);
    |         return verifyCallResult(success, returndata, errorMessage);
    |     }
    | 
    |     /**
    |      * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
    |      * revert reason using the provided one.
    |      *
    |      * _Available since v4.3._
    |      */
    |     function verifyCallResult(
    |         bool success,
    |         bytes memory returndata,
    |         string memory errorMessage
    |     ) internal pure returns (bytes memory) {
    |         if (success) {
    |             return returndata;
    |         } else {
    |             // Look for revert reason and bubble it up if present
    |             if (returndata.length > 0) {
    |                 // The easiest way to bubble the revert reason is using memory via assembly
    |                 /// @solidity memory-safe-assembly
    |                 assembly {
    |                     let returndata_size := mload(returndata)
    |                     revert(add(32, returndata), returndata_size)
    |                 }
    |             } else {
    |                 revert(errorMessage);
    |             }
    |         }
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
    | 
    | pragma solidity ^0.8.0;
    | import "../proxy/utils/Initializable.sol";
    | 
    | /**
    |  * @dev Provides information about the current execution context, including the
    |  * sender of the transaction and its data. While these are generally available
    |  * via msg.sender and msg.data, they should not be accessed in such a direct
    |  * manner, since when dealing with meta-transactions the account sending and
    |  * paying for execution may not be the actual sender (as far as an application
    |  * is concerned).
    |  *
    |  * This contract is only required for intermediate, library-like contracts.
    |  */
    | abstract contract ContextUpgradeable is Initializable {
    |     function __Context_init() internal onlyInitializing {
    |     }
    | 
    |     function __Context_init_unchained() internal onlyInitializing {
    |     }
    |     function _msgSender() internal view virtual returns (address) {
    |         return msg.sender;
    |     }
    | 
    |     function _msgData() internal view virtual returns (bytes calldata) {
    |         return msg.data;
    |     }
    | 
    |     /**
    |      * @dev This empty reserved space is put in place to allow future versions to add new
    |      * variables without shifting down storage in the inheritance chain.
    |      * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps
    |      */
    |     uint256[50] private __gap;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Library for reading and writing primitive types to specific storage slots.
    |  *
    |  * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
    |  * This library helps with reading and writing to such slots without the need for inline assembly.
    |  *
    |  * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
    |  *
    |  * Example usage to set ERC1967 implementation slot:
    |  * ```
    |  * contract ERC1967 {
    |  *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    |  *
    |  *     function _getImplementation() internal view returns (address) {
    |  *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
    |  *     }
    |  *
    |  *     function _setImplementation(address newImplementation) internal {
    |  *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");
    |  *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
    |  *     }
    |  * }
    |  * ```
    |  *
    |  * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._
    |  */
    | library StorageSlotUpgradeable {
    |     struct AddressSlot {
    |         address value;
    |     }
    | 
    |     struct BooleanSlot {
    |         bool value;
    |     }
    | 
    |     struct Bytes32Slot {
    |         bytes32 value;
    |     }
    | 
    |     struct Uint256Slot {
    |         uint256 value;
    |     }
    | 
    |     /**
    |      * @dev Returns an `AddressSlot` with member `value` located at `slot`.
    |      */
    |     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             r.slot := slot
    |         }
    |     }
    | 
    |     /**
    |      * @dev Returns an `BooleanSlot` with member `value` located at `slot`.
    |      */
    |     function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             r.slot := slot
    |         }
    |     }
    | 
    |     /**
    |      * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.
    |      */
    |     function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             r.slot := slot
    |         }
    |     }
    | 
    |     /**
    |      * @dev Returns an `Uint256Slot` with member `value` located at `slot`.
    |      */
    |     function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             r.slot := slot
    |         }
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Interface of the ERC165 standard, as defined in the
    |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
    |  *
    |  * Implementers can declare support of contract interfaces, which can then be
    |  * queried by others ({ERC165Checker}).
    |  *
    |  * For an implementation, see {ERC165}.
    |  */
    | interface IERC165Upgradeable {
    |     /**
    |      * @dev Returns true if this contract implements the interface defined by
    |      * `interfaceId`. See the corresponding
    |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
    |      * to learn more about how these ids are created.
    |      *
    |      * This function call must use less than 30 000 gas.
    |      */
    |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Library for managing
    |  * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive
    |  * types.
    |  *
    |  * Sets have the following properties:
    |  *
    |  * - Elements are added, removed, and checked for existence in constant time
    |  * (O(1)).
    |  * - Elements are enumerated in O(n). No guarantees are made on the ordering.
    |  *
    |  * ```
    |  * contract Example {
    |  *     // Add the library methods
    |  *     using EnumerableSet for EnumerableSet.AddressSet;
    |  *
    |  *     // Declare a set state variable
    |  *     EnumerableSet.AddressSet private mySet;
    |  * }
    |  * ```
    |  *
    |  * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)
    |  * and `uint256` (`UintSet`) are supported.
    |  *
    |  * [WARNING]
    |  * ====
    |  *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.
    |  *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.
    |  *
    |  *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.
    |  * ====
    |  */
    | library EnumerableSetUpgradeable {
    |     // To implement this library for multiple types with as little code
    |     // repetition as possible, we write it in terms of a generic Set type with
    |     // bytes32 values.
    |     // The Set implementation uses private functions, and user-facing
    |     // implementations (such as AddressSet) are just wrappers around the
    |     // underlying Set.
    |     // This means that we can only create new EnumerableSets for types that fit
    |     // in bytes32.
    | 
    |     struct Set {
    |         // Storage of set values
    |         bytes32[] _values;
    |         // Position of the value in the `values` array, plus 1 because index 0
    |         // means a value is not in the set.
    |         mapping(bytes32 => uint256) _indexes;
    |     }
    | 
    |     /**
    |      * @dev Add a value to a set. O(1).
    |      *
    |      * Returns true if the value was added to the set, that is if it was not
    |      * already present.
    |      */
    |     function _add(Set storage set, bytes32 value) private returns (bool) {
    |         if (!_contains(set, value)) {
    |             set._values.push(value);
    |             // The value is stored at length-1, but we add 1 to all indexes
    |             // and use 0 as a sentinel value
    |             set._indexes[value] = set._values.length;
    |             return true;
    |         } else {
    |             return false;
    |         }
    |     }
    | 
    |     /**
    |      * @dev Removes a value from a set. O(1).
    |      *
    |      * Returns true if the value was removed from the set, that is if it was
    |      * present.
    |      */
    |     function _remove(Set storage set, bytes32 value) private returns (bool) {
    |         // We read and store the value's index to prevent multiple reads from the same storage slot
    |         uint256 valueIndex = set._indexes[value];
    | 
    |         if (valueIndex != 0) {
    |             // Equivalent to contains(set, value)
    |             // To delete an element from the _values array in O(1), we swap the element to delete with the last one in
    |             // the array, and then remove the last element (sometimes called as 'swap and pop').
    |             // This modifies the order of the array, as noted in {at}.
    | 
    |             uint256 toDeleteIndex = valueIndex - 1;
    |             uint256 lastIndex = set._values.length - 1;
    | 
    |             if (lastIndex != toDeleteIndex) {
    |                 bytes32 lastValue = set._values[lastIndex];
    | 
    |                 // Move the last value to the index where the value to delete is
    |                 set._values[toDeleteIndex] = lastValue;
    |                 // Update the index for the moved value
    |                 set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex
    |             }
    | 
    |             // Delete the slot where the moved value was stored
    |             set._values.pop();
    | 
    |             // Delete the index for the deleted slot
    |             delete set._indexes[value];
    | 
    |             return true;
    |         } else {
    |             return false;
    |         }
    |     }
    | 
    |     /**
    |      * @dev Returns true if the value is in the set. O(1).
    |      */
    |     function _contains(Set storage set, bytes32 value) private view returns (bool) {
    |         return set._indexes[value] != 0;
    |     }
    | 
    |     /**
    |      * @dev Returns the number of values on the set. O(1).
    |      */
    |     function _length(Set storage set) private view returns (uint256) {
    |         return set._values.length;
    |     }
    | 
    |     /**
    |      * @dev Returns the value stored at position `index` in the set. O(1).
    |      *
    |      * Note that there are no guarantees on the ordering of values inside the
    |      * array, and it may change when more values are added or removed.
    |      *
    |      * Requirements:
    |      *
    |      * - `index` must be strictly less than {length}.
    |      */
    |     function _at(Set storage set, uint256 index) private view returns (bytes32) {
    |         return set._values[index];
    |     }
    | 
    |     /**
    |      * @dev Return the entire set in an array
    |      *
    |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
    |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
    |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
    |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
    |      */
    |     function _values(Set storage set) private view returns (bytes32[] memory) {
    |         return set._values;
    |     }
    | 
    |     // Bytes32Set
    | 
    |     struct Bytes32Set {
    |         Set _inner;
    |     }
    | 
    |     /**
    |      * @dev Add a value to a set. O(1).
    |      *
    |      * Returns true if the value was added to the set, that is if it was not
    |      * already present.
    |      */
    |     function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {
    |         return _add(set._inner, value);
    |     }
    | 
    |     /**
    |      * @dev Removes a value from a set. O(1).
    |      *
    |      * Returns true if the value was removed from the set, that is if it was
    |      * present.
    |      */
    |     function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {
    |         return _remove(set._inner, value);
    |     }
    | 
    |     /**
    |      * @dev Returns true if the value is in the set. O(1).
    |      */
    |     function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {
    |         return _contains(set._inner, value);
    |     }
    | 
    |     /**
    |      * @dev Returns the number of values in the set. O(1).
    |      */
    |     function length(Bytes32Set storage set) internal view returns (uint256) {
    |         return _length(set._inner);
    |     }
    | 
    |     /**
    |      * @dev Returns the value stored at position `index` in the set. O(1).
    |      *
    |      * Note that there are no guarantees on the ordering of values inside the
    |      * array, and it may change when more values are added or removed.
    |      *
    |      * Requirements:
    |      *
    |      * - `index` must be strictly less than {length}.
    |      */
    |     function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {
    |         return _at(set._inner, index);
    |     }
    | 
    |     /**
    |      * @dev Return the entire set in an array
    |      *
    |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
    |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
    |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
    |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
    |      */
    |     function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {
    |         return _values(set._inner);
    |     }
    | 
    |     // AddressSet
    | 
    |     struct AddressSet {
    |         Set _inner;
    |     }
    | 
    |     /**
    |      * @dev Add a value to a set. O(1).
    |      *
    |      * Returns true if the value was added to the set, that is if it was not
    |      * already present.
    |      */
    |     function add(AddressSet storage set, address value) internal returns (bool) {
    |         return _add(set._inner, bytes32(uint256(uint160(value))));
    |     }
    | 
    |     /**
    |      * @dev Removes a value from a set. O(1).
    |      *
    |      * Returns true if the value was removed from the set, that is if it was
    |      * present.
    |      */
    |     function remove(AddressSet storage set, address value) internal returns (bool) {
    |         return _remove(set._inner, bytes32(uint256(uint160(value))));
    |     }
    | 
    |     /**
    |      * @dev Returns true if the value is in the set. O(1).
    |      */
    |     function contains(AddressSet storage set, address value) internal view returns (bool) {
    |         return _contains(set._inner, bytes32(uint256(uint160(value))));
    |     }
    | 
    |     /**
    |      * @dev Returns the number of values in the set. O(1).
    |      */
    |     function length(AddressSet storage set) internal view returns (uint256) {
    |         return _length(set._inner);
    |     }
    | 
    |     /**
    |      * @dev Returns the value stored at position `index` in the set. O(1).
    |      *
    |      * Note that there are no guarantees on the ordering of values inside the
    |      * array, and it may change when more values are added or removed.
    |      *
    |      * Requirements:
    |      *
    |      * - `index` must be strictly less than {length}.
    |      */
    |     function at(AddressSet storage set, uint256 index) internal view returns (address) {
    |         return address(uint160(uint256(_at(set._inner, index))));
    |     }
    | 
    |     /**
    |      * @dev Return the entire set in an array
    |      *
    |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
    |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
    |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
    |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
    |      */
    |     function values(AddressSet storage set) internal view returns (address[] memory) {
    |         bytes32[] memory store = _values(set._inner);
    |         address[] memory result;
    | 
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             result := store
    |         }
    | 
    |         return result;
    |     }
    | 
    |     // UintSet
    | 
    |     struct UintSet {
    |         Set _inner;
    |     }
    | 
    |     /**
    |      * @dev Add a value to a set. O(1).
    |      *
    |      * Returns true if the value was added to the set, that is if it was not
    |      * already present.
    |      */
    |     function add(UintSet storage set, uint256 value) internal returns (bool) {
    |         return _add(set._inner, bytes32(value));
    |     }
    | 
    |     /**
    |      * @dev Removes a value from a set. O(1).
    |      *
    |      * Returns true if the value was removed from the set, that is if it was
    |      * present.
    |      */
    |     function remove(UintSet storage set, uint256 value) internal returns (bool) {
    |         return _remove(set._inner, bytes32(value));
    |     }
    | 
    |     /**
    |      * @dev Returns true if the value is in the set. O(1).
    |      */
    |     function contains(UintSet storage set, uint256 value) internal view returns (bool) {
    |         return _contains(set._inner, bytes32(value));
    |     }
    | 
    |     /**
    |      * @dev Returns the number of values on the set. O(1).
    |      */
    |     function length(UintSet storage set) internal view returns (uint256) {
    |         return _length(set._inner);
    |     }
    | 
    |     /**
    |      * @dev Returns the value stored at position `index` in the set. O(1).
    |      *
    |      * Note that there are no guarantees on the ordering of values inside the
    |      * array, and it may change when more values are added or removed.
    |      *
    |      * Requirements:
    |      *
    |      * - `index` must be strictly less than {length}.
    |      */
    |     function at(UintSet storage set, uint256 index) internal view returns (uint256) {
    |         return uint256(_at(set._inner, index));
    |     }
    | 
    |     /**
    |      * @dev Return the entire set in an array
    |      *
    |      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed
    |      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that
    |      * this function has an unbounded cost, and using it as part of a state-changing function may render the function
    |      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.
    |      */
    |     function values(UintSet storage set) internal view returns (uint256[] memory) {
    |         bytes32[] memory store = _values(set._inner);
    |         uint256[] memory result;
    | 
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             result := store
    |         }
    | 
    |         return result;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/access/Ownable.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../utils/Context.sol";
    | 
    | /**
    |  * @dev Contract module which provides a basic access control mechanism, where
    |  * there is an account (an owner) that can be granted exclusive access to
    |  * specific functions.
    |  *
    |  * By default, the owner account will be the one that deploys the contract. This
    |  * can later be changed with {transferOwnership}.
    |  *
    |  * This module is used through inheritance. It will make available the modifier
    |  * `onlyOwner`, which can be applied to your functions to restrict their use to
    |  * the owner.
    |  */
    | abstract contract Ownable is Context {
    |     address private _owner;
    | 
    |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    | 
    |     /**
    |      * @dev Initializes the contract setting the deployer as the initial owner.
    |      */
    |     constructor() {
    |         _transferOwnership(_msgSender());
    |     }
    | 
    |     /**
    |      * @dev Throws if called by any account other than the owner.
    |      */
    |     modifier onlyOwner() {
    |         _checkOwner();
    |         _;
    |     }
    | 
    |     /**
    |      * @dev Returns the address of the current owner.
    |      */
    |     function owner() public view virtual returns (address) {
    |         return _owner;
    |     }
    | 
    |     /**
    |      * @dev Throws if the sender is not the owner.
    |      */
    |     function _checkOwner() internal view virtual {
    |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
    |     }
    | 
    |     /**
    |      * @dev Leaves the contract without owner. It will not be possible to call
    |      * `onlyOwner` functions anymore. Can only be called by the current owner.
    |      *
    |      * NOTE: Renouncing ownership will leave the contract without an owner,
    |      * thereby removing any functionality that is only available to the owner.
    |      */
    |     function renounceOwnership() public virtual onlyOwner {
    |         _transferOwnership(address(0));
    |     }
    | 
    |     /**
    |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
    |      * Can only be called by the current owner.
    |      */
    |     function transferOwnership(address newOwner) public virtual onlyOwner {
    |         require(newOwner != address(0), "Ownable: new owner is the zero address");
    |         _transferOwnership(newOwner);
    |     }
    | 
    |     /**
    |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
    |      * Internal function without access restriction.
    |      */
    |     function _transferOwnership(address newOwner) internal virtual {
    |         address oldOwner = _owner;
    |         _owner = newOwner;
    |         emit OwnershipTransferred(oldOwner, newOwner);
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/interfaces/draft-IERC1822.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified
    |  * proxy whose upgrades are fully controlled by the current implementation.
    |  */
    | interface IERC1822Proxiable {
    |     /**
    |      * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation
    |      * address.
    |      *
    |      * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks
    |      * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this
    |      * function revert if invoked through a proxy.
    |      */
    |     function proxiableUUID() external view returns (bytes32);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../Proxy.sol";
    | import "./ERC1967Upgrade.sol";
    | 
    | /**
    |  * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an
    |  * implementation address that can be changed. This address is stored in storage in the location specified by
    |  * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the
    |  * implementation behind the proxy.
    |  */
    | contract ERC1967Proxy is Proxy, ERC1967Upgrade {
    |     /**
    |      * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.
    |      *
    |      * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded
    |      * function call, and allows initializing the storage of the proxy like a Solidity constructor.
    |      */
    |     constructor(address _logic, bytes memory _data) payable {
    |         _upgradeToAndCall(_logic, _data, false);
    |     }
    | 
    |     /**
    |      * @dev Returns the current implementation address.
    |      */
*r  |     function _implementation() internal view virtual override returns (address impl) {
*r  |         return ERC1967Upgrade._getImplementation();
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)
    | 
    | pragma solidity ^0.8.2;
    | 
    | import "../beacon/IBeacon.sol";
    | import "../../interfaces/draft-IERC1822.sol";
    | import "../../utils/Address.sol";
    | import "../../utils/StorageSlot.sol";
    | 
    | /**
    |  * @dev This abstract contract provides getters and event emitting update functions for
    |  * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.
    |  *
    |  * _Available since v4.1._
    |  *
    |  * @custom:oz-upgrades-unsafe-allow delegatecall
    |  */
    | abstract contract ERC1967Upgrade {
    |     // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1
    |     bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;
    | 
    |     /**
    |      * @dev Storage slot with the address of the current implementation.
    |      * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is
    |      * validated in the constructor.
    |      */
*r  |     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    | 
    |     /**
    |      * @dev Emitted when the implementation is upgraded.
    |      */
    |     event Upgraded(address indexed implementation);
    | 
    |     /**
    |      * @dev Returns the current implementation address.
    |      */
*r  |     function _getImplementation() internal view returns (address) {
*r  |         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
    |     }
    | 
    |     /**
    |      * @dev Stores a new address in the EIP1967 implementation slot.
    |      */
    |     function _setImplementation(address newImplementation) private {
r   |         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");
*r  |         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
    |     }
    | 
    |     /**
    |      * @dev Perform implementation upgrade
    |      *
    |      * Emits an {Upgraded} event.
    |      */
*r  |     function _upgradeTo(address newImplementation) internal {
*r  |         _setImplementation(newImplementation);
*r  |         emit Upgraded(newImplementation);
    |     }
    | 
    |     /**
    |      * @dev Perform implementation upgrade with additional setup call.
    |      *
    |      * Emits an {Upgraded} event.
    |      */
    |     function _upgradeToAndCall(
    |         address newImplementation,
    |         bytes memory data,
    |         bool forceCall
    |     ) internal {
    |         _upgradeTo(newImplementation);
    |         if (data.length > 0 || forceCall) {
    |             Address.functionDelegateCall(newImplementation, data);
    |         }
    |     }
    | 
    |     /**
    |      * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.
    |      *
    |      * Emits an {Upgraded} event.
    |      */
    |     function _upgradeToAndCallUUPS(
    |         address newImplementation,
    |         bytes memory data,
    |         bool forceCall
    |     ) internal {
    |         // Upgrades from old implementations will perform a rollback test. This test requires the new
    |         // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing
    |         // this special case will break upgrade paths from old UUPS implementation to new ones.
    |         if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {
    |             _setImplementation(newImplementation);
    |         } else {
    |             try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {
    |                 require(slot == _IMPLEMENTATION_SLOT, "ERC1967Upgrade: unsupported proxiableUUID");
    |             } catch {
    |                 revert("ERC1967Upgrade: new implementation is not UUPS");
    |             }
    |             _upgradeToAndCall(newImplementation, data, forceCall);
    |         }
    |     }
    | 
    |     /**
    |      * @dev Storage slot with the admin of the contract.
    |      * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is
    |      * validated in the constructor.
    |      */
    |     bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;
    | 
    |     /**
    |      * @dev Emitted when the admin account has changed.
    |      */
    |     event AdminChanged(address previousAdmin, address newAdmin);
    | 
    |     /**
    |      * @dev Returns the current admin.
    |      */
    |     function _getAdmin() internal view returns (address) {
    |         return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;
    |     }
    | 
    |     /**
    |      * @dev Stores a new address in the EIP1967 admin slot.
    |      */
    |     function _setAdmin(address newAdmin) private {
    |         require(newAdmin != address(0), "ERC1967: new admin is the zero address");
    |         StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;
    |     }
    | 
    |     /**
    |      * @dev Changes the admin of the proxy.
    |      *
    |      * Emits an {AdminChanged} event.
    |      */
    |     function _changeAdmin(address newAdmin) internal {
    |         emit AdminChanged(_getAdmin(), newAdmin);
    |         _setAdmin(newAdmin);
    |     }
    | 
    |     /**
    |      * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.
    |      * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.
    |      */
    |     bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;
    | 
    |     /**
    |      * @dev Emitted when the beacon is upgraded.
    |      */
    |     event BeaconUpgraded(address indexed beacon);
    | 
    |     /**
    |      * @dev Returns the current beacon.
    |      */
    |     function _getBeacon() internal view returns (address) {
    |         return StorageSlot.getAddressSlot(_BEACON_SLOT).value;
    |     }
    | 
    |     /**
    |      * @dev Stores a new beacon in the EIP1967 beacon slot.
    |      */
    |     function _setBeacon(address newBeacon) private {
    |         require(Address.isContract(newBeacon), "ERC1967: new beacon is not a contract");
    |         require(
    |             Address.isContract(IBeacon(newBeacon).implementation()),
    |             "ERC1967: beacon implementation is not a contract"
    |         );
    |         StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;
    |     }
    | 
    |     /**
    |      * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does
    |      * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).
    |      *
    |      * Emits a {BeaconUpgraded} event.
    |      */
    |     function _upgradeBeaconToAndCall(
    |         address newBeacon,
    |         bytes memory data,
    |         bool forceCall
    |     ) internal {
    |         _setBeacon(newBeacon);
    |         emit BeaconUpgraded(newBeacon);
    |         if (data.length > 0 || forceCall) {
    |             Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);
    |         }
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/proxy/Proxy.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
    |  * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
    |  * be specified by overriding the virtual {_implementation} function.
    |  *
    |  * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
    |  * different contract through the {_delegate} function.
    |  *
    |  * The success and return data of the delegated call will be returned back to the caller of the proxy.
    |  */
    | abstract contract Proxy {
    |     /**
    |      * @dev Delegates the current call to `implementation`.
    |      *
    |      * This function does not return to its internal call site, it will return directly to the external caller.
    |      */
*r  |     function _delegate(address implementation) internal virtual {
    |         assembly {
    |             // Copy msg.data. We take full control of memory in this inline assembly
    |             // block because it will not return to Solidity code. We overwrite the
    |             // Solidity scratch pad at memory position 0.
*r  |             calldatacopy(0, 0, calldatasize())
    | 
    |             // Call the implementation.
    |             // out and outsize are 0 because we don't know the size yet.
*r  |             let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
    | 
    |             // Copy the returned data.
*r  |             returndatacopy(0, 0, returndatasize())
    | 
*r  |             switch result
    |             // delegatecall returns 0 on error.
*r  |             case 0 {
*r  |                 revert(0, returndatasize())
    |             }
    |             default {
*   |                 return(0, returndatasize())
    |             }
    |         }
    |     }
    | 
    |     /**
    |      * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function
    |      * and {_fallback} should delegate.
    |      */
    |     function _implementation() internal view virtual returns (address);
    | 
    |     /**
    |      * @dev Delegates the current call to the address returned by `_implementation()`.
    |      *
    |      * This function does not return to its internal call site, it will return directly to the external caller.
    |      */
*r  |     function _fallback() internal virtual {
    |         _beforeFallback();
*r  |         _delegate(_implementation());
    |     }
    | 
    |     /**
    |      * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other
    |      * function in the contract matches the call data.
    |      */
    |     fallback() external payable virtual {
*r  |         _fallback();
    |     }
    | 
    |     /**
    |      * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data
    |      * is empty.
    |      */
    |     receive() external payable virtual {
*r  |         _fallback();
    |     }
    | 
    |     /**
    |      * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`
    |      * call, or as part of the Solidity `fallback` or `receive` functions.
    |      *
    |      * If overridden should call `super._beforeFallback()`.
    |      */
    |     function _beforeFallback() internal virtual {}
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "./IBeacon.sol";
    | import "../Proxy.sol";
    | import "../ERC1967/ERC1967Upgrade.sol";
    | 
    | /**
    |  * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.
    |  *
    |  * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't
    |  * conflict with the storage layout of the implementation behind the proxy.
    |  *
    |  * _Available since v3.4._
    |  */
    | contract BeaconProxy is Proxy, ERC1967Upgrade {
    |     /**
    |      * @dev Initializes the proxy with `beacon`.
    |      *
    |      * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This
    |      * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity
    |      * constructor.
    |      *
    |      * Requirements:
    |      *
    |      * - `beacon` must be a contract with the interface {IBeacon}.
    |      */
    |     constructor(address beacon, bytes memory data) payable {
    |         _upgradeBeaconToAndCall(beacon, data, false);
    |     }
    | 
    |     /**
    |      * @dev Returns the current beacon address.
    |      */
    |     function _beacon() internal view virtual returns (address) {
    |         return _getBeacon();
    |     }
    | 
    |     /**
    |      * @dev Returns the current implementation address of the associated beacon.
    |      */
    |     function _implementation() internal view virtual override returns (address) {
    |         return IBeacon(_getBeacon()).implementation();
    |     }
    | 
    |     /**
    |      * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.
    |      *
    |      * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.
    |      *
    |      * Requirements:
    |      *
    |      * - `beacon` must be a contract.
    |      * - The implementation returned by `beacon` must be a contract.
    |      */
    |     function _setBeacon(address beacon, bytes memory data) internal virtual {
    |         _upgradeBeaconToAndCall(beacon, data, false);
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/proxy/beacon/IBeacon.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev This is the interface that {BeaconProxy} expects of its beacon.
    |  */
    | interface IBeacon {
    |     /**
    |      * @dev Must return an address that can be used as a delegate call target.
    |      *
    |      * {BeaconProxy} will check that this address is a contract.
    |      */
    |     function implementation() external view returns (address);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "./IBeacon.sol";
    | import "../../access/Ownable.sol";
    | import "../../utils/Address.sol";
    | 
    | /**
    |  * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their
    |  * implementation contract, which is where they will delegate all function calls.
    |  *
    |  * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.
    |  */
    | contract UpgradeableBeacon is IBeacon, Ownable {
    |     address private _implementation;
    | 
    |     /**
    |      * @dev Emitted when the implementation returned by the beacon is changed.
    |      */
    |     event Upgraded(address indexed implementation);
    | 
    |     /**
    |      * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the
    |      * beacon.
    |      */
    |     constructor(address implementation_) {
    |         _setImplementation(implementation_);
    |     }
    | 
    |     /**
    |      * @dev Returns the current implementation address.
    |      */
    |     function implementation() public view virtual override returns (address) {
    |         return _implementation;
    |     }
    | 
    |     /**
    |      * @dev Upgrades the beacon to a new implementation.
    |      *
    |      * Emits an {Upgraded} event.
    |      *
    |      * Requirements:
    |      *
    |      * - msg.sender must be the owner of the contract.
    |      * - `newImplementation` must be a contract.
    |      */
    |     function upgradeTo(address newImplementation) public virtual onlyOwner {
    |         _setImplementation(newImplementation);
    |         emit Upgraded(newImplementation);
    |     }
    | 
    |     /**
    |      * @dev Sets the implementation contract address for this beacon
    |      *
    |      * Requirements:
    |      *
    |      * - `newImplementation` must be a contract.
    |      */
    |     function _setImplementation(address newImplementation) private {
    |         require(Address.isContract(newImplementation), "UpgradeableBeacon: implementation is not a contract");
    |         _implementation = newImplementation;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "./IERC20.sol";
    | import "./extensions/IERC20Metadata.sol";
    | import "../../utils/Context.sol";
    | 
    | /**
    |  * @dev Implementation of the {IERC20} interface.
    |  *
    |  * This implementation is agnostic to the way tokens are created. This means
    |  * that a supply mechanism has to be added in a derived contract using {_mint}.
    |  * For a generic mechanism see {ERC20PresetMinterPauser}.
    |  *
    |  * TIP: For a detailed writeup see our guide
    |  * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
    |  * to implement supply mechanisms].
    |  *
    |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
    |  * instead returning `false` on failure. This behavior is nonetheless
    |  * conventional and does not conflict with the expectations of ERC20
    |  * applications.
    |  *
    |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
    |  * This allows applications to reconstruct the allowance for all accounts just
    |  * by listening to said events. Other implementations of the EIP may not emit
    |  * these events, as it isn't required by the specification.
    |  *
    |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
    |  * functions have been added to mitigate the well-known issues around setting
    |  * allowances. See {IERC20-approve}.
    |  */
    | contract ERC20 is Context, IERC20, IERC20Metadata {
    |     mapping(address => uint256) private _balances;
    | 
    |     mapping(address => mapping(address => uint256)) private _allowances;
    | 
    |     uint256 private _totalSupply;
    | 
    |     string private _name;
    |     string private _symbol;
    | 
    |     /**
    |      * @dev Sets the values for {name} and {symbol}.
    |      *
    |      * The default value of {decimals} is 18. To select a different value for
    |      * {decimals} you should overload it.
    |      *
    |      * All two of these values are immutable: they can only be set once during
    |      * construction.
    |      */
    |     constructor(string memory name_, string memory symbol_) {
    |         _name = name_;
    |         _symbol = symbol_;
    |     }
    | 
    |     /**
    |      * @dev Returns the name of the token.
    |      */
    |     function name() public view virtual override returns (string memory) {
    |         return _name;
    |     }
    | 
    |     /**
    |      * @dev Returns the symbol of the token, usually a shorter version of the
    |      * name.
    |      */
    |     function symbol() public view virtual override returns (string memory) {
    |         return _symbol;
    |     }
    | 
    |     /**
    |      * @dev Returns the number of decimals used to get its user representation.
    |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
    |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
    |      *
    |      * Tokens usually opt for a value of 18, imitating the relationship between
    |      * Ether and Wei. This is the value {ERC20} uses, unless this function is
    |      * overridden;
    |      *
    |      * NOTE: This information is only used for _display_ purposes: it in
    |      * no way affects any of the arithmetic of the contract, including
    |      * {IERC20-balanceOf} and {IERC20-transfer}.
    |      */
    |     function decimals() public view virtual override returns (uint8) {
    |         return 18;
    |     }
    | 
    |     /**
    |      * @dev See {IERC20-totalSupply}.
    |      */
    |     function totalSupply() public view virtual override returns (uint256) {
    |         return _totalSupply;
    |     }
    | 
    |     /**
    |      * @dev See {IERC20-balanceOf}.
    |      */
    |     function balanceOf(address account) public view virtual override returns (uint256) {
    |         return _balances[account];
    |     }
    | 
    |     /**
    |      * @dev See {IERC20-transfer}.
    |      *
    |      * Requirements:
    |      *
    |      * - `to` cannot be the zero address.
    |      * - the caller must have a balance of at least `amount`.
    |      */
    |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
    |         address owner = _msgSender();
    |         _transfer(owner, to, amount);
    |         return true;
    |     }
    | 
    |     /**
    |      * @dev See {IERC20-allowance}.
    |      */
    |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
    |         return _allowances[owner][spender];
    |     }
    | 
    |     /**
    |      * @dev See {IERC20-approve}.
    |      *
    |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
    |      * `transferFrom`. This is semantically equivalent to an infinite approval.
    |      *
    |      * Requirements:
    |      *
    |      * - `spender` cannot be the zero address.
    |      */
    |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
    |         address owner = _msgSender();
    |         _approve(owner, spender, amount);
    |         return true;
    |     }
    | 
    |     /**
    |      * @dev See {IERC20-transferFrom}.
    |      *
    |      * Emits an {Approval} event indicating the updated allowance. This is not
    |      * required by the EIP. See the note at the beginning of {ERC20}.
    |      *
    |      * NOTE: Does not update the allowance if the current allowance
    |      * is the maximum `uint256`.
    |      *
    |      * Requirements:
    |      *
    |      * - `from` and `to` cannot be the zero address.
    |      * - `from` must have a balance of at least `amount`.
    |      * - the caller must have allowance for ``from``'s tokens of at least
    |      * `amount`.
    |      */
    |     function transferFrom(
    |         address from,
    |         address to,
    |         uint256 amount
    |     ) public virtual override returns (bool) {
    |         address spender = _msgSender();
    |         _spendAllowance(from, spender, amount);
    |         _transfer(from, to, amount);
    |         return true;
    |     }
    | 
    |     /**
    |      * @dev Atomically increases the allowance granted to `spender` by the caller.
    |      *
    |      * This is an alternative to {approve} that can be used as a mitigation for
    |      * problems described in {IERC20-approve}.
    |      *
    |      * Emits an {Approval} event indicating the updated allowance.
    |      *
    |      * Requirements:
    |      *
    |      * - `spender` cannot be the zero address.
    |      */
    |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
    |         address owner = _msgSender();
    |         _approve(owner, spender, allowance(owner, spender) + addedValue);
    |         return true;
    |     }
    | 
    |     /**
    |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
    |      *
    |      * This is an alternative to {approve} that can be used as a mitigation for
    |      * problems described in {IERC20-approve}.
    |      *
    |      * Emits an {Approval} event indicating the updated allowance.
    |      *
    |      * Requirements:
    |      *
    |      * - `spender` cannot be the zero address.
    |      * - `spender` must have allowance for the caller of at least
    |      * `subtractedValue`.
    |      */
    |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
    |         address owner = _msgSender();
    |         uint256 currentAllowance = allowance(owner, spender);
    |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
    |         unchecked {
    |             _approve(owner, spender, currentAllowance - subtractedValue);
    |         }
    | 
    |         return true;
    |     }
    | 
    |     /**
    |      * @dev Moves `amount` of tokens from `from` to `to`.
    |      *
    |      * This internal function is equivalent to {transfer}, and can be used to
    |      * e.g. implement automatic token fees, slashing mechanisms, etc.
    |      *
    |      * Emits a {Transfer} event.
    |      *
    |      * Requirements:
    |      *
    |      * - `from` cannot be the zero address.
    |      * - `to` cannot be the zero address.
    |      * - `from` must have a balance of at least `amount`.
    |      */
    |     function _transfer(
    |         address from,
    |         address to,
    |         uint256 amount
    |     ) internal virtual {
    |         require(from != address(0), "ERC20: transfer from the zero address");
    |         require(to != address(0), "ERC20: transfer to the zero address");
    | 
    |         _beforeTokenTransfer(from, to, amount);
    | 
    |         uint256 fromBalance = _balances[from];
    |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
    |         unchecked {
    |             _balances[from] = fromBalance - amount;
    |         }
    |         _balances[to] += amount;
    | 
    |         emit Transfer(from, to, amount);
    | 
    |         _afterTokenTransfer(from, to, amount);
    |     }
    | 
    |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
    |      * the total supply.
    |      *
    |      * Emits a {Transfer} event with `from` set to the zero address.
    |      *
    |      * Requirements:
    |      *
    |      * - `account` cannot be the zero address.
    |      */
    |     function _mint(address account, uint256 amount) internal virtual {
    |         require(account != address(0), "ERC20: mint to the zero address");
    | 
    |         _beforeTokenTransfer(address(0), account, amount);
    | 
    |         _totalSupply += amount;
    |         _balances[account] += amount;
    |         emit Transfer(address(0), account, amount);
    | 
    |         _afterTokenTransfer(address(0), account, amount);
    |     }
    | 
    |     /**
    |      * @dev Destroys `amount` tokens from `account`, reducing the
    |      * total supply.
    |      *
    |      * Emits a {Transfer} event with `to` set to the zero address.
    |      *
    |      * Requirements:
    |      *
    |      * - `account` cannot be the zero address.
    |      * - `account` must have at least `amount` tokens.
    |      */
    |     function _burn(address account, uint256 amount) internal virtual {
    |         require(account != address(0), "ERC20: burn from the zero address");
    | 
    |         _beforeTokenTransfer(account, address(0), amount);
    | 
    |         uint256 accountBalance = _balances[account];
    |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
    |         unchecked {
    |             _balances[account] = accountBalance - amount;
    |         }
    |         _totalSupply -= amount;
    | 
    |         emit Transfer(account, address(0), amount);
    | 
    |         _afterTokenTransfer(account, address(0), amount);
    |     }
    | 
    |     /**
    |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
    |      *
    |      * This internal function is equivalent to `approve`, and can be used to
    |      * e.g. set automatic allowances for certain subsystems, etc.
    |      *
    |      * Emits an {Approval} event.
    |      *
    |      * Requirements:
    |      *
    |      * - `owner` cannot be the zero address.
    |      * - `spender` cannot be the zero address.
    |      */
    |     function _approve(
    |         address owner,
    |         address spender,
    |         uint256 amount
    |     ) internal virtual {
    |         require(owner != address(0), "ERC20: approve from the zero address");
    |         require(spender != address(0), "ERC20: approve to the zero address");
    | 
    |         _allowances[owner][spender] = amount;
    |         emit Approval(owner, spender, amount);
    |     }
    | 
    |     /**
    |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
    |      *
    |      * Does not update the allowance amount in case of infinite allowance.
    |      * Revert if not enough allowance is available.
    |      *
    |      * Might emit an {Approval} event.
    |      */
    |     function _spendAllowance(
    |         address owner,
    |         address spender,
    |         uint256 amount
    |     ) internal virtual {
    |         uint256 currentAllowance = allowance(owner, spender);
    |         if (currentAllowance != type(uint256).max) {
    |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
    |             unchecked {
    |                 _approve(owner, spender, currentAllowance - amount);
    |             }
    |         }
    |     }
    | 
    |     /**
    |      * @dev Hook that is called before any transfer of tokens. This includes
    |      * minting and burning.
    |      *
    |      * Calling conditions:
    |      *
    |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
    |      * will be transferred to `to`.
    |      * - when `from` is zero, `amount` tokens will be minted for `to`.
    |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
    |      * - `from` and `to` are never both zero.
    |      *
    |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
    |      */
    |     function _beforeTokenTransfer(
    |         address from,
    |         address to,
    |         uint256 amount
    |     ) internal virtual {}
    | 
    |     /**
    |      * @dev Hook that is called after any transfer of tokens. This includes
    |      * minting and burning.
    |      *
    |      * Calling conditions:
    |      *
    |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
    |      * has been transferred to `to`.
    |      * - when `from` is zero, `amount` tokens have been minted for `to`.
    |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
    |      * - `from` and `to` are never both zero.
    |      *
    |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
    |      */
    |     function _afterTokenTransfer(
    |         address from,
    |         address to,
    |         uint256 amount
    |     ) internal virtual {}
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Interface of the ERC20 standard as defined in the EIP.
    |  */
    | interface IERC20 {
    |     /**
    |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
    |      * another (`to`).
    |      *
    |      * Note that `value` may be zero.
    |      */
    |     event Transfer(address indexed from, address indexed to, uint256 value);
    | 
    |     /**
    |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
    |      * a call to {approve}. `value` is the new allowance.
    |      */
    |     event Approval(address indexed owner, address indexed spender, uint256 value);
    | 
    |     /**
    |      * @dev Returns the amount of tokens in existence.
    |      */
    |     function totalSupply() external view returns (uint256);
    | 
    |     /**
    |      * @dev Returns the amount of tokens owned by `account`.
    |      */
    |     function balanceOf(address account) external view returns (uint256);
    | 
    |     /**
    |      * @dev Moves `amount` tokens from the caller's account to `to`.
    |      *
    |      * Returns a boolean value indicating whether the operation succeeded.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function transfer(address to, uint256 amount) external returns (bool);
    | 
    |     /**
    |      * @dev Returns the remaining number of tokens that `spender` will be
    |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
    |      * zero by default.
    |      *
    |      * This value changes when {approve} or {transferFrom} are called.
    |      */
    |     function allowance(address owner, address spender) external view returns (uint256);
    | 
    |     /**
    |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
    |      *
    |      * Returns a boolean value indicating whether the operation succeeded.
    |      *
    |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
    |      * that someone may use both the old and the new allowance by unfortunate
    |      * transaction ordering. One possible solution to mitigate this race
    |      * condition is to first reduce the spender's allowance to 0 and set the
    |      * desired value afterwards:
    |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
    |      *
    |      * Emits an {Approval} event.
    |      */
    |     function approve(address spender, uint256 amount) external returns (bool);
    | 
    |     /**
    |      * @dev Moves `amount` tokens from `from` to `to` using the
    |      * allowance mechanism. `amount` is then deducted from the caller's
    |      * allowance.
    |      *
    |      * Returns a boolean value indicating whether the operation succeeded.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function transferFrom(
    |         address from,
    |         address to,
    |         uint256 amount
    |     ) external returns (bool);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../IERC20.sol";
    | 
    | /**
    |  * @dev Interface for the optional metadata functions from the ERC20 standard.
    |  *
    |  * _Available since v4.1._
    |  */
    | interface IERC20Metadata is IERC20 {
    |     /**
    |      * @dev Returns the name of the token.
    |      */
    |     function name() external view returns (string memory);
    | 
    |     /**
    |      * @dev Returns the symbol of the token.
    |      */
    |     function symbol() external view returns (string memory);
    | 
    |     /**
    |      * @dev Returns the decimals places of the token.
    |      */
    |     function decimals() external view returns (uint8);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "./IERC721.sol";
    | import "./IERC721Receiver.sol";
    | import "./extensions/IERC721Metadata.sol";
    | import "../../utils/Address.sol";
    | import "../../utils/Context.sol";
    | import "../../utils/Strings.sol";
    | import "../../utils/introspection/ERC165.sol";
    | 
    | /**
    |  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
    |  * the Metadata extension, but not including the Enumerable extension, which is available separately as
    |  * {ERC721Enumerable}.
    |  */
    | contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
    |     using Address for address;
    |     using Strings for uint256;
    | 
    |     // Token name
    |     string private _name;
    | 
    |     // Token symbol
    |     string private _symbol;
    | 
    |     // Mapping from token ID to owner address
    |     mapping(uint256 => address) private _owners;
    | 
    |     // Mapping owner address to token count
    |     mapping(address => uint256) private _balances;
    | 
    |     // Mapping from token ID to approved address
    |     mapping(uint256 => address) private _tokenApprovals;
    | 
    |     // Mapping from owner to operator approvals
    |     mapping(address => mapping(address => bool)) private _operatorApprovals;
    | 
    |     /**
    |      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
    |      */
    |     constructor(string memory name_, string memory symbol_) {
    |         _name = name_;
    |         _symbol = symbol_;
    |     }
    | 
    |     /**
    |      * @dev See {IERC165-supportsInterface}.
    |      */
    |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
    |         return
    |             interfaceId == type(IERC721).interfaceId ||
    |             interfaceId == type(IERC721Metadata).interfaceId ||
    |             super.supportsInterface(interfaceId);
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-balanceOf}.
    |      */
    |     function balanceOf(address owner) public view virtual override returns (uint256) {
    |         require(owner != address(0), "ERC721: address zero is not a valid owner");
    |         return _balances[owner];
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-ownerOf}.
    |      */
    |     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
    |         address owner = _owners[tokenId];
    |         require(owner != address(0), "ERC721: invalid token ID");
    |         return owner;
    |     }
    | 
    |     /**
    |      * @dev See {IERC721Metadata-name}.
    |      */
    |     function name() public view virtual override returns (string memory) {
    |         return _name;
    |     }
    | 
    |     /**
    |      * @dev See {IERC721Metadata-symbol}.
    |      */
    |     function symbol() public view virtual override returns (string memory) {
    |         return _symbol;
    |     }
    | 
    |     /**
    |      * @dev See {IERC721Metadata-tokenURI}.
    |      */
    |     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
    |         _requireMinted(tokenId);
    | 
    |         string memory baseURI = _baseURI();
    |         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
    |     }
    | 
    |     /**
    |      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
    |      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
    |      * by default, can be overridden in child contracts.
    |      */
    |     function _baseURI() internal view virtual returns (string memory) {
    |         return "";
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-approve}.
    |      */
    |     function approve(address to, uint256 tokenId) public virtual override {
    |         address owner = ERC721.ownerOf(tokenId);
    |         require(to != owner, "ERC721: approval to current owner");
    | 
    |         require(
    |             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
    |             "ERC721: approve caller is not token owner nor approved for all"
    |         );
    | 
    |         _approve(to, tokenId);
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-getApproved}.
    |      */
    |     function getApproved(uint256 tokenId) public view virtual override returns (address) {
    |         _requireMinted(tokenId);
    | 
    |         return _tokenApprovals[tokenId];
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-setApprovalForAll}.
    |      */
    |     function setApprovalForAll(address operator, bool approved) public virtual override {
    |         _setApprovalForAll(_msgSender(), operator, approved);
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-isApprovedForAll}.
    |      */
    |     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
    |         return _operatorApprovals[owner][operator];
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-transferFrom}.
    |      */
    |     function transferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) public virtual override {
    |         //solhint-disable-next-line max-line-length
    |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner nor approved");
    | 
    |         _transfer(from, to, tokenId);
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-safeTransferFrom}.
    |      */
    |     function safeTransferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) public virtual override {
    |         safeTransferFrom(from, to, tokenId, "");
    |     }
    | 
    |     /**
    |      * @dev See {IERC721-safeTransferFrom}.
    |      */
    |     function safeTransferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId,
    |         bytes memory data
    |     ) public virtual override {
    |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner nor approved");
    |         _safeTransfer(from, to, tokenId, data);
    |     }
    | 
    |     /**
    |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
    |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
    |      *
    |      * `data` is additional data, it has no specified format and it is sent in call to `to`.
    |      *
    |      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
    |      * implement alternative mechanisms to perform token transfer, such as signature-based.
    |      *
    |      * Requirements:
    |      *
    |      * - `from` cannot be the zero address.
    |      * - `to` cannot be the zero address.
    |      * - `tokenId` token must exist and be owned by `from`.
    |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function _safeTransfer(
    |         address from,
    |         address to,
    |         uint256 tokenId,
    |         bytes memory data
    |     ) internal virtual {
    |         _transfer(from, to, tokenId);
    |         require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");
    |     }
    | 
    |     /**
    |      * @dev Returns whether `tokenId` exists.
    |      *
    |      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
    |      *
    |      * Tokens start existing when they are minted (`_mint`),
    |      * and stop existing when they are burned (`_burn`).
    |      */
    |     function _exists(uint256 tokenId) internal view virtual returns (bool) {
    |         return _owners[tokenId] != address(0);
    |     }
    | 
    |     /**
    |      * @dev Returns whether `spender` is allowed to manage `tokenId`.
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must exist.
    |      */
    |     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
    |         address owner = ERC721.ownerOf(tokenId);
    |         return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);
    |     }
    | 
    |     /**
    |      * @dev Safely mints `tokenId` and transfers it to `to`.
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must not exist.
    |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function _safeMint(address to, uint256 tokenId) internal virtual {
    |         _safeMint(to, tokenId, "");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
    |      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
    |      */
    |     function _safeMint(
    |         address to,
    |         uint256 tokenId,
    |         bytes memory data
    |     ) internal virtual {
    |         _mint(to, tokenId);
    |         require(
    |             _checkOnERC721Received(address(0), to, tokenId, data),
    |             "ERC721: transfer to non ERC721Receiver implementer"
    |         );
    |     }
    | 
    |     /**
    |      * @dev Mints `tokenId` and transfers it to `to`.
    |      *
    |      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must not exist.
    |      * - `to` cannot be the zero address.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function _mint(address to, uint256 tokenId) internal virtual {
    |         require(to != address(0), "ERC721: mint to the zero address");
    |         require(!_exists(tokenId), "ERC721: token already minted");
    | 
    |         _beforeTokenTransfer(address(0), to, tokenId);
    | 
    |         _balances[to] += 1;
    |         _owners[tokenId] = to;
    | 
    |         emit Transfer(address(0), to, tokenId);
    | 
    |         _afterTokenTransfer(address(0), to, tokenId);
    |     }
    | 
    |     /**
    |      * @dev Destroys `tokenId`.
    |      * The approval is cleared when the token is burned.
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must exist.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function _burn(uint256 tokenId) internal virtual {
    |         address owner = ERC721.ownerOf(tokenId);
    | 
    |         _beforeTokenTransfer(owner, address(0), tokenId);
    | 
    |         // Clear approvals
    |         _approve(address(0), tokenId);
    | 
    |         _balances[owner] -= 1;
    |         delete _owners[tokenId];
    | 
    |         emit Transfer(owner, address(0), tokenId);
    | 
    |         _afterTokenTransfer(owner, address(0), tokenId);
    |     }
    | 
    |     /**
    |      * @dev Transfers `tokenId` from `from` to `to`.
    |      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
    |      *
    |      * Requirements:
    |      *
    |      * - `to` cannot be the zero address.
    |      * - `tokenId` token must be owned by `from`.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function _transfer(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) internal virtual {
    |         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
    |         require(to != address(0), "ERC721: transfer to the zero address");
    | 
    |         _beforeTokenTransfer(from, to, tokenId);
    | 
    |         // Clear approvals from the previous owner
    |         _approve(address(0), tokenId);
    | 
    |         _balances[from] -= 1;
    |         _balances[to] += 1;
    |         _owners[tokenId] = to;
    | 
    |         emit Transfer(from, to, tokenId);
    | 
    |         _afterTokenTransfer(from, to, tokenId);
    |     }
    | 
    |     /**
    |      * @dev Approve `to` to operate on `tokenId`
    |      *
    |      * Emits an {Approval} event.
    |      */
    |     function _approve(address to, uint256 tokenId) internal virtual {
    |         _tokenApprovals[tokenId] = to;
    |         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
    |     }
    | 
    |     /**
    |      * @dev Approve `operator` to operate on all of `owner` tokens
    |      *
    |      * Emits an {ApprovalForAll} event.
    |      */
    |     function _setApprovalForAll(
    |         address owner,
    |         address operator,
    |         bool approved
    |     ) internal virtual {
    |         require(owner != operator, "ERC721: approve to caller");
    |         _operatorApprovals[owner][operator] = approved;
    |         emit ApprovalForAll(owner, operator, approved);
    |     }
    | 
    |     /**
    |      * @dev Reverts if the `tokenId` has not been minted yet.
    |      */
    |     function _requireMinted(uint256 tokenId) internal view virtual {
    |         require(_exists(tokenId), "ERC721: invalid token ID");
    |     }
    | 
    |     /**
    |      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
    |      * The call is not executed if the target address is not a contract.
    |      *
    |      * @param from address representing the previous owner of the given token ID
    |      * @param to target address that will receive the tokens
    |      * @param tokenId uint256 ID of the token to be transferred
    |      * @param data bytes optional data to send along with the call
    |      * @return bool whether the call correctly returned the expected magic value
    |      */
    |     function _checkOnERC721Received(
    |         address from,
    |         address to,
    |         uint256 tokenId,
    |         bytes memory data
    |     ) private returns (bool) {
    |         if (to.isContract()) {
    |             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {
    |                 return retval == IERC721Receiver.onERC721Received.selector;
    |             } catch (bytes memory reason) {
    |                 if (reason.length == 0) {
    |                     revert("ERC721: transfer to non ERC721Receiver implementer");
    |                 } else {
    |                     /// @solidity memory-safe-assembly
    |                     assembly {
    |                         revert(add(32, reason), mload(reason))
    |                     }
    |                 }
    |             }
    |         } else {
    |             return true;
    |         }
    |     }
    | 
    |     /**
    |      * @dev Hook that is called before any token transfer. This includes minting
    |      * and burning.
    |      *
    |      * Calling conditions:
    |      *
    |      * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be
    |      * transferred to `to`.
    |      * - When `from` is zero, `tokenId` will be minted for `to`.
    |      * - When `to` is zero, ``from``'s `tokenId` will be burned.
    |      * - `from` and `to` are never both zero.
    |      *
    |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
    |      */
    |     function _beforeTokenTransfer(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) internal virtual {}
    | 
    |     /**
    |      * @dev Hook that is called after any transfer of tokens. This includes
    |      * minting and burning.
    |      *
    |      * Calling conditions:
    |      *
    |      * - when `from` and `to` are both non-zero.
    |      * - `from` and `to` are never both zero.
    |      *
    |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
    |      */
    |     function _afterTokenTransfer(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) internal virtual {}
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../../utils/introspection/IERC165.sol";
    | 
    | /**
    |  * @dev Required interface of an ERC721 compliant contract.
    |  */
    | interface IERC721 is IERC165 {
    |     /**
    |      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
    |      */
    |     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    | 
    |     /**
    |      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
    |      */
    |     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
    | 
    |     /**
    |      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
    |      */
    |     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    | 
    |     /**
    |      * @dev Returns the number of tokens in ``owner``'s account.
    |      */
    |     function balanceOf(address owner) external view returns (uint256 balance);
    | 
    |     /**
    |      * @dev Returns the owner of the `tokenId` token.
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must exist.
    |      */
    |     function ownerOf(uint256 tokenId) external view returns (address owner);
    | 
    |     /**
    |      * @dev Safely transfers `tokenId` token from `from` to `to`.
    |      *
    |      * Requirements:
    |      *
    |      * - `from` cannot be the zero address.
    |      * - `to` cannot be the zero address.
    |      * - `tokenId` token must exist and be owned by `from`.
    |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
    |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function safeTransferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId,
    |         bytes calldata data
    |     ) external;
    | 
    |     /**
    |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
    |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
    |      *
    |      * Requirements:
    |      *
    |      * - `from` cannot be the zero address.
    |      * - `to` cannot be the zero address.
    |      * - `tokenId` token must exist and be owned by `from`.
    |      * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
    |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function safeTransferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) external;
    | 
    |     /**
    |      * @dev Transfers `tokenId` token from `from` to `to`.
    |      *
    |      * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
    |      *
    |      * Requirements:
    |      *
    |      * - `from` cannot be the zero address.
    |      * - `to` cannot be the zero address.
    |      * - `tokenId` token must be owned by `from`.
    |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
    |      *
    |      * Emits a {Transfer} event.
    |      */
    |     function transferFrom(
    |         address from,
    |         address to,
    |         uint256 tokenId
    |     ) external;
    | 
    |     /**
    |      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
    |      * The approval is cleared when the token is transferred.
    |      *
    |      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
    |      *
    |      * Requirements:
    |      *
    |      * - The caller must own the token or be an approved operator.
    |      * - `tokenId` must exist.
    |      *
    |      * Emits an {Approval} event.
    |      */
    |     function approve(address to, uint256 tokenId) external;
    | 
    |     /**
    |      * @dev Approve or remove `operator` as an operator for the caller.
    |      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
    |      *
    |      * Requirements:
    |      *
    |      * - The `operator` cannot be the caller.
    |      *
    |      * Emits an {ApprovalForAll} event.
    |      */
    |     function setApprovalForAll(address operator, bool _approved) external;
    | 
    |     /**
    |      * @dev Returns the account approved for `tokenId` token.
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must exist.
    |      */
    |     function getApproved(uint256 tokenId) external view returns (address operator);
    | 
    |     /**
    |      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
    |      *
    |      * See {setApprovalForAll}
    |      */
    |     function isApprovedForAll(address owner, address operator) external view returns (bool);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @title ERC721 token receiver interface
    |  * @dev Interface for any contract that wants to support safeTransfers
    |  * from ERC721 asset contracts.
    |  */
    | interface IERC721Receiver {
    |     /**
    |      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
    |      * by `operator` from `from`, this function is called.
    |      *
    |      * It must return its Solidity selector to confirm the token transfer.
    |      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
    |      *
    |      * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
    |      */
    |     function onERC721Received(
    |         address operator,
    |         address from,
    |         uint256 tokenId,
    |         bytes calldata data
    |     ) external returns (bytes4);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721URIStorage.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../ERC721.sol";
    | 
    | /**
    |  * @dev ERC721 token with storage based token URI management.
    |  */
    | abstract contract ERC721URIStorage is ERC721 {
    |     using Strings for uint256;
    | 
    |     // Optional mapping for token URIs
    |     mapping(uint256 => string) private _tokenURIs;
    | 
    |     /**
    |      * @dev See {IERC721Metadata-tokenURI}.
    |      */
    |     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
    |         _requireMinted(tokenId);
    | 
    |         string memory _tokenURI = _tokenURIs[tokenId];
    |         string memory base = _baseURI();
    | 
    |         // If there is no base URI, return the token URI.
    |         if (bytes(base).length == 0) {
    |             return _tokenURI;
    |         }
    |         // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).
    |         if (bytes(_tokenURI).length > 0) {
    |             return string(abi.encodePacked(base, _tokenURI));
    |         }
    | 
    |         return super.tokenURI(tokenId);
    |     }
    | 
    |     /**
    |      * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
    |      *
    |      * Requirements:
    |      *
    |      * - `tokenId` must exist.
    |      */
    |     function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {
    |         require(_exists(tokenId), "ERC721URIStorage: URI set of nonexistent token");
    |         _tokenURIs[tokenId] = _tokenURI;
    |     }
    | 
    |     /**
    |      * @dev See {ERC721-_burn}. This override additionally checks to see if a
    |      * token-specific URI was set for the token, and if so, it deletes the token URI from
    |      * the storage mapping.
    |      */
    |     function _burn(uint256 tokenId) internal virtual override {
    |         super._burn(tokenId);
    | 
    |         if (bytes(_tokenURIs[tokenId]).length != 0) {
    |             delete _tokenURIs[tokenId];
    |         }
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "../IERC721.sol";
    | 
    | /**
    |  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
    |  * @dev See https://eips.ethereum.org/EIPS/eip-721
    |  */
    | interface IERC721Metadata is IERC721 {
    |     /**
    |      * @dev Returns the token collection name.
    |      */
    |     function name() external view returns (string memory);
    | 
    |     /**
    |      * @dev Returns the token collection symbol.
    |      */
    |     function symbol() external view returns (string memory);
    | 
    |     /**
    |      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
    |      */
    |     function tokenURI(uint256 tokenId) external view returns (string memory);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/utils/Address.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)
    | 
    | pragma solidity ^0.8.1;
    | 
    | /**
    |  * @dev Collection of functions related to the address type
    |  */
    | library Address {
    |     /**
    |      * @dev Returns true if `account` is a contract.
    |      *
    |      * [IMPORTANT]
    |      * ====
    |      * It is unsafe to assume that an address for which this function returns
    |      * false is an externally-owned account (EOA) and not a contract.
    |      *
    |      * Among others, `isContract` will return false for the following
    |      * types of addresses:
    |      *
    |      *  - an externally-owned account
    |      *  - a contract in construction
    |      *  - an address where a contract will be created
    |      *  - an address where a contract lived, but was destroyed
    |      * ====
    |      *
    |      * [IMPORTANT]
    |      * ====
    |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
    |      *
    |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
    |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
    |      * constructor.
    |      * ====
    |      */
*r  |     function isContract(address account) internal view returns (bool) {
    |         // This method relies on extcodesize/address.code.length, which returns 0
    |         // for contracts in construction, since the code is only stored at the end
    |         // of the constructor execution.
    | 
*r  |         return account.code.length > 0;
    |     }
    | 
    |     /**
    |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
    |      * `recipient`, forwarding all available gas and reverting on errors.
    |      *
    |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
    |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
    |      * imposed by `transfer`, making them unable to receive funds via
    |      * `transfer`. {sendValue} removes this limitation.
    |      *
    |      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
    |      *
    |      * IMPORTANT: because control is transferred to `recipient`, care must be
    |      * taken to not create reentrancy vulnerabilities. Consider using
    |      * {ReentrancyGuard} or the
    |      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
    |      */
    |     function sendValue(address payable recipient, uint256 amount) internal {
    |         require(address(this).balance >= amount, "Address: insufficient balance");
    | 
    |         (bool success, ) = recipient.call{value: amount}("");
    |         require(success, "Address: unable to send value, recipient may have reverted");
    |     }
    | 
    |     /**
    |      * @dev Performs a Solidity function call using a low level `call`. A
    |      * plain `call` is an unsafe replacement for a function call: use this
    |      * function instead.
    |      *
    |      * If `target` reverts with a revert reason, it is bubbled up by this
    |      * function (like regular Solidity function calls).
    |      *
    |      * Returns the raw returned data. To convert to the expected return value,
    |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
    |      *
    |      * Requirements:
    |      *
    |      * - `target` must be a contract.
    |      * - calling `target` with `data` must not revert.
    |      *
    |      * _Available since v3.1._
    |      */
    |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
    |         return functionCall(target, data, "Address: low-level call failed");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
    |      * `errorMessage` as a fallback revert reason when `target` reverts.
    |      *
    |      * _Available since v3.1._
    |      */
    |     function functionCall(
    |         address target,
    |         bytes memory data,
    |         string memory errorMessage
    |     ) internal returns (bytes memory) {
    |         return functionCallWithValue(target, data, 0, errorMessage);
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
    |      * but also transferring `value` wei to `target`.
    |      *
    |      * Requirements:
    |      *
    |      * - the calling contract must have an ETH balance of at least `value`.
    |      * - the called Solidity function must be `payable`.
    |      *
    |      * _Available since v3.1._
    |      */
    |     function functionCallWithValue(
    |         address target,
    |         bytes memory data,
    |         uint256 value
    |     ) internal returns (bytes memory) {
    |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
    |      * with `errorMessage` as a fallback revert reason when `target` reverts.
    |      *
    |      * _Available since v3.1._
    |      */
    |     function functionCallWithValue(
    |         address target,
    |         bytes memory data,
    |         uint256 value,
    |         string memory errorMessage
    |     ) internal returns (bytes memory) {
    |         require(address(this).balance >= value, "Address: insufficient balance for call");
    |         require(isContract(target), "Address: call to non-contract");
    | 
    |         (bool success, bytes memory returndata) = target.call{value: value}(data);
    |         return verifyCallResult(success, returndata, errorMessage);
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
    |      * but performing a static call.
    |      *
    |      * _Available since v3.3._
    |      */
    |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
    |         return functionStaticCall(target, data, "Address: low-level static call failed");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
    |      * but performing a static call.
    |      *
    |      * _Available since v3.3._
    |      */
    |     function functionStaticCall(
    |         address target,
    |         bytes memory data,
    |         string memory errorMessage
    |     ) internal view returns (bytes memory) {
    |         require(isContract(target), "Address: static call to non-contract");
    | 
    |         (bool success, bytes memory returndata) = target.staticcall(data);
    |         return verifyCallResult(success, returndata, errorMessage);
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
    |      * but performing a delegate call.
    |      *
    |      * _Available since v3.4._
    |      */
*r  |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
*r  |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    |     }
    | 
    |     /**
    |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
    |      * but performing a delegate call.
    |      *
    |      * _Available since v3.4._
    |      */
*r  |     function functionDelegateCall(
    |         address target,
    |         bytes memory data,
    |         string memory errorMessage
    |     ) internal returns (bytes memory) {
r   |         require(isContract(target), "Address: delegate call to non-contract");
    | 
*r  |         (bool success, bytes memory returndata) = target.delegatecall(data);
*r  |         return verifyCallResult(success, returndata, errorMessage);
    |     }
    | 
    |     /**
    |      * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
    |      * revert reason using the provided one.
    |      *
    |      * _Available since v4.3._
    |      */
*r  |     function verifyCallResult(
    |         bool success,
    |         bytes memory returndata,
    |         string memory errorMessage
*r  |     ) internal pure returns (bytes memory) {
*r  |         if (success) {
*r  |             return returndata;
    |         } else {
    |             // Look for revert reason and bubble it up if present
*r  |             if (returndata.length > 0) {
    |                 // The easiest way to bubble the revert reason is using memory via assembly
    |                 /// @solidity memory-safe-assembly
    |                 assembly {
r   |                     let returndata_size := mload(returndata)
r   |                     revert(add(32, returndata), returndata_size)
    |                 }
    |             } else {
*r  |                 revert(errorMessage);
    |             }
    |         }
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/utils/Context.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Provides information about the current execution context, including the
    |  * sender of the transaction and its data. While these are generally available
    |  * via msg.sender and msg.data, they should not be accessed in such a direct
    |  * manner, since when dealing with meta-transactions the account sending and
    |  * paying for execution may not be the actual sender (as far as an application
    |  * is concerned).
    |  *
    |  * This contract is only required for intermediate, library-like contracts.
    |  */
    | abstract contract Context {
    |     function _msgSender() internal view virtual returns (address) {
    |         return msg.sender;
    |     }
    | 
    |     function _msgData() internal view virtual returns (bytes calldata) {
    |         return msg.data;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/utils/Counters.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @title Counters
    |  * @author Matt Condon (@shrugs)
    |  * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number
    |  * of elements in a mapping, issuing ERC721 ids, or counting request ids.
    |  *
    |  * Include with `using Counters for Counters.Counter;`
    |  */
    | library Counters {
    |     struct Counter {
    |         // This variable should never be directly accessed by users of the library: interactions must be restricted to
    |         // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
    |         // this feature: see https://github.com/ethereum/solidity/issues/4637
    |         uint256 _value; // default: 0
    |     }
    | 
    |     function current(Counter storage counter) internal view returns (uint256) {
    |         return counter._value;
    |     }
    | 
    |     function increment(Counter storage counter) internal {
    |         unchecked {
    |             counter._value += 1;
    |         }
    |     }
    | 
    |     function decrement(Counter storage counter) internal {
    |         uint256 value = counter._value;
    |         require(value > 0, "Counter: decrement overflow");
    |         unchecked {
    |             counter._value = value - 1;
    |         }
    |     }
    | 
    |     function reset(Counter storage counter) internal {
    |         counter._value = 0;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/utils/StorageSlot.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Library for reading and writing primitive types to specific storage slots.
    |  *
    |  * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
    |  * This library helps with reading and writing to such slots without the need for inline assembly.
    |  *
    |  * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
    |  *
    |  * Example usage to set ERC1967 implementation slot:
    |  * ```
    |  * contract ERC1967 {
    |  *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
    |  *
    |  *     function _getImplementation() internal view returns (address) {
    |  *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
    |  *     }
    |  *
    |  *     function _setImplementation(address newImplementation) internal {
    |  *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");
    |  *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
    |  *     }
    |  * }
    |  * ```
    |  *
    |  * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._
    |  */
    | library StorageSlot {
    |     struct AddressSlot {
    |         address value;
    |     }
    | 
    |     struct BooleanSlot {
    |         bool value;
    |     }
    | 
    |     struct Bytes32Slot {
    |         bytes32 value;
    |     }
    | 
    |     struct Uint256Slot {
    |         uint256 value;
    |     }
    | 
    |     /**
    |      * @dev Returns an `AddressSlot` with member `value` located at `slot`.
    |      */
*r  |     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
    |         /// @solidity memory-safe-assembly
    |         assembly {
*r  |             r.slot := slot
    |         }
    |     }
    | 
    |     /**
    |      * @dev Returns an `BooleanSlot` with member `value` located at `slot`.
    |      */
    |     function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             r.slot := slot
    |         }
    |     }
    | 
    |     /**
    |      * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.
    |      */
    |     function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             r.slot := slot
    |         }
    |     }
    | 
    |     /**
    |      * @dev Returns an `Uint256Slot` with member `value` located at `slot`.
    |      */
    |     function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
    |         /// @solidity memory-safe-assembly
    |         assembly {
    |             r.slot := slot
    |         }
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/utils/Strings.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev String operations.
    |  */
    | library Strings {
    |     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
    |     uint8 private constant _ADDRESS_LENGTH = 20;
    | 
    |     /**
    |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
    |      */
    |     function toString(uint256 value) internal pure returns (string memory) {
    |         // Inspired by OraclizeAPI's implementation - MIT licence
    |         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
    | 
    |         if (value == 0) {
    |             return "0";
    |         }
    |         uint256 temp = value;
    |         uint256 digits;
    |         while (temp != 0) {
    |             digits++;
    |             temp /= 10;
    |         }
    |         bytes memory buffer = new bytes(digits);
    |         while (value != 0) {
    |             digits -= 1;
    |             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
    |             value /= 10;
    |         }
    |         return string(buffer);
    |     }
    | 
    |     /**
    |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
    |      */
    |     function toHexString(uint256 value) internal pure returns (string memory) {
    |         if (value == 0) {
    |             return "0x00";
    |         }
    |         uint256 temp = value;
    |         uint256 length = 0;
    |         while (temp != 0) {
    |             length++;
    |             temp >>= 8;
    |         }
    |         return toHexString(value, length);
    |     }
    | 
    |     /**
    |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
    |      */
    |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
    |         bytes memory buffer = new bytes(2 * length + 2);
    |         buffer[0] = "0";
    |         buffer[1] = "x";
    |         for (uint256 i = 2 * length + 1; i > 1; --i) {
    |             buffer[i] = _HEX_SYMBOLS[value & 0xf];
    |             value >>= 4;
    |         }
    |         require(value == 0, "Strings: hex length insufficient");
    |         return string(buffer);
    |     }
    | 
    |     /**
    |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
    |      */
    |     function toHexString(address addr) internal pure returns (string memory) {
    |         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | import "./IERC165.sol";
    | 
    | /**
    |  * @dev Implementation of the {IERC165} interface.
    |  *
    |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
    |  * for the additional interface id that will be supported. For example:
    |  *
    |  * ```solidity
    |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
    |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
    |  * }
    |  * ```
    |  *
    |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
    |  */
    | abstract contract ERC165 is IERC165 {
    |     /**
    |      * @dev See {IERC165-supportsInterface}.
    |      */
    |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
    |         return interfaceId == type(IERC165).interfaceId;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol
    | // SPDX-License-Identifier: MIT
    | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
    | 
    | pragma solidity ^0.8.0;
    | 
    | /**
    |  * @dev Interface of the ERC165 standard, as defined in the
    |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
    |  *
    |  * Implementers can declare support of contract interfaces, which can then be
    |  * queried by others ({ERC165Checker}).
    |  *
    |  * For an implementation, see {ERC165}.
    |  */
    | interface IERC165 {
    |     /**
    |      * @dev Returns true if this contract implements the interface defined by
    |      * `interfaceId`. See the corresponding
    |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
    |      * to learn more about how these ids are created.
    |      *
    |      * This function call must use less than 30 000 gas.
    |      */
    |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Implementations/AtomicBountyV1.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../Storage/AtomicBountyStorage.sol';
    | 
    | /// @title AtomicBountyV1
    | /// @author FlacoJones
    | /// @notice Bounty implementation for single contributor, single payout scenarios (e.g. 500 USDC for a single work completion)
    | /// @dev AtomicBountyV1 -> AtomicBountyStorageV1 -> BountyCore -> BountyStorageCore -> Core Dependencies (OZ + Custom)
r   | /// @dev Do not add any new storage variables here. Put them in a AtomicBountyStorageV# and release new implementation
    | contract AtomicBountyV1 is AtomicBountyStorageV1 {
    |     using SafeERC20Upgradeable for IERC20Upgradeable;
    |     using AddressUpgradeable for address payable;
    |     using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
    | 
    |     constructor() {}
    | 
    |     /// @notice Initializes a bounty proxy with initial state
    |     /// @param _bountyId The unique bounty identifier
    |     /// @param _issuer The sender of the mint bounty transaction
    |     /// @param _organization The organization associated with the bounty
    |     /// @param _openQ The OpenQProxy address
    |     /// @param _claimManager The Claim Manager proxy address
    |     /// @param _depositManager The Deposit Manager proxy address
    |     /// @param _operation The ABI encoded data determining the type of bounty being initialized and associated data
    |     /// @dev see IBountyCore.initialize.(_operation) for _operation ABI encoding schema for ATOMIC
    |     function initialize(
    |         string memory _bountyId,
    |         address _issuer,
    |         string memory _organization,
    |         address _openQ,
    |         address _claimManager,
    |         address _depositManager,
    |         OpenQDefinitions.InitOperation memory _operation
    |     ) external initializer {
    |         require(bytes(_bountyId).length != 0, Errors.NO_EMPTY_BOUNTY_ID);
    |         require(bytes(_organization).length != 0, Errors.NO_EMPTY_ORGANIZATION);
    | 
    |         __ReentrancyGuard_init();
    | 
    |         __OnlyOpenQ_init(_openQ);
    |         __ClaimManagerOwnable_init(_claimManager);
    |         __DepositManagerOwnable_init(_depositManager);
    | 
    |         bountyId = _bountyId;
    |         issuer = _issuer;
    |         organization = _organization;
    |         bountyCreatedTime = block.timestamp;
    |         nftDepositLimit = 5;
    | 
    |         (
    |             bool _hasFundingGoal,
    |             address _fundingToken,
    |             uint256 _fundingGoal,
    |             bool _invoiceRequired,
    |             bool _kycRequired,
    |             bool _supportingDocumentsRequired,
    |             string memory _issuerExternalUserId,
    |             ,
    | 
    |         ) = abi.decode(
    |                 _operation.data,
    |                 (
    |                     bool,
    |                     address,
    |                     uint256,
    |                     bool,
    |                     bool,
    |                     bool,
    |                     string,
    |                     string,
    |                     string
    |                 )
    |             );
    | 
    |         bountyType = OpenQDefinitions.ATOMIC;
    |         hasFundingGoal = _hasFundingGoal;
    |         fundingToken = _fundingToken;
    |         fundingGoal = _fundingGoal;
    |         invoiceRequired = _invoiceRequired;
    |         kycRequired = _kycRequired;
    |         supportingDocumentsRequired = _supportingDocumentsRequired;
    |         issuerExternalUserId = _issuerExternalUserId;
    |     }
    | 
    |     /// @notice Transfers full balance of _tokenAddress from bounty to _payoutAddress
    |     /// @param _tokenAddress ERC20 token address or Zero Address for protocol token
    |     /// @param _payoutAddress The destination address for the funds
    |     function claimBalance(address _payoutAddress, address _tokenAddress)
    |         external
    |         onlyClaimManager
    |         nonReentrant
    |         returns (uint256)
    |     {
    |         uint256 claimedBalance = getTokenBalance(_tokenAddress);
    |         _transferToken(_tokenAddress, claimedBalance, _payoutAddress);
    |         return claimedBalance;
    |     }
    | 
    |     /// @notice Changes bounty status from 0 (OPEN) to 1 (CLOSED)
    |     /// @param _payoutAddress The closer of the bounty
    |     /// @param _closerData ABI-encoded data about the claimant and claimant asset (see IBountyAtomic for data spec)
    |     /// @dev See IAtomicBounty.close.(_closerData)for _closerData ABI encoding schema
    |     function close(address _payoutAddress, bytes calldata _closerData)
    |         external
    |         onlyClaimManager
    |     {
    |         require(
    |             status == OpenQDefinitions.OPEN,
    |             Errors.CONTRACT_ALREADY_CLOSED
    |         );
    |         require(_payoutAddress != address(0), Errors.NO_ZERO_ADDRESS);
    |         status = OpenQDefinitions.CLOSED;
    |         closer = _payoutAddress;
    |         bountyClosedTime = block.timestamp;
    |         closerData = _closerData;
    |     }
    | 
    |     /// @notice Receives an NFT for this contract
    |     /// @param _sender Sender of the NFT
    |     /// @param _tokenAddress NFT token address
    |     /// @param _tokenId NFT token id
    |     /// @param _expiration How long before this deposit becomes refundable
    |     /// @return bytes32 the deposit id
    |     function receiveNft(
    |         address _sender,
    |         address _tokenAddress,
    |         uint256 _tokenId,
    |         uint256 _expiration,
    |         bytes calldata
    |     ) external onlyDepositManager nonReentrant returns (bytes32) {
    |         require(
    |             nftDeposits.length < nftDepositLimit,
    |             Errors.NFT_DEPOSIT_LIMIT_REACHED
    |         );
    |         require(_expiration > 0, Errors.EXPIRATION_NOT_GREATER_THAN_ZERO);
    |         _receiveNft(_tokenAddress, _sender, _tokenId);
    | 
    |         bytes32 depositId = _generateDepositId();
    | 
    |         funder[depositId] = _sender;
    |         tokenAddress[depositId] = _tokenAddress;
    |         depositTime[depositId] = block.timestamp;
    |         tokenId[depositId] = _tokenId;
    |         expiration[depositId] = _expiration;
    |         isNFT[depositId] = true;
    | 
    |         deposits.push(depositId);
    |         nftDeposits.push(depositId);
    | 
    |         return depositId;
    |     }
    | 
    |     /// @notice Whether or not invoice has been completed
    |     /// @param _data ABI encoded data
    |     /// @dev see IBountyCore.setInvoiceComplete.(_data) for _data ABI encoding schema
    |     function setInvoiceComplete(bytes calldata _data) external onlyOpenQ {
    |         bool _invoiceComplete = abi.decode(_data, (bool));
    |         invoiceComplete = _invoiceComplete;
    |     }
    | 
    |     /// @notice Whether or not supporting documents have been completed
    |     /// @param _data ABI encoded data
    |     /// @dev see IBountyCore.setSupportingDocumentsComplete.(_data) for _data ABI encoding schema
    |     function setSupportingDocumentsComplete(bytes calldata _data)
    |         external
    |         onlyOpenQ
    |     {
    |         bool _supportingDocumentsComplete = abi.decode(_data, (bool));
    |         supportingDocumentsComplete = _supportingDocumentsComplete;
    |     }
    | 
    |     /// @notice Returns whether or not invoice is completed
    |     /// @return True if completed, false otherwise
    |     /// @dev We return from all getInvoiceComplete as bytes to accomodate different return types
    |     /// @dev _data (bool)
    |     /// @dev _data (invoiceComplete)
    |     function getInvoiceComplete() external view returns (bytes memory) {
    |         return abi.encode(invoiceComplete);
    |     }
    | 
    |     /// @notice Returns whether or not supporting documents have been completed
    |     /// @return True if completed, false otherwise
    |     /// @dev We return from all IBountyCore.getSupportingDocumentsComplete() as bytes to accomodate different return types
    |     /// @dev _data (bool)
    |     /// @dev _data (supportingDocumentsComplete)
    |     function getSupportingDocumentsComplete()
    |         external
    |         view
    |         returns (bytes memory)
    |     {
    |         return abi.encode(supportingDocumentsComplete);
    |     }
    | 
    |     /// @notice receive() method to accept protocol tokens
    |     receive() external payable {
    |         revert(
    |             'Cannot send Ether directly to boutny contract. Please use the BountyV1.receiveFunds() method.'
    |         );
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Implementations/BountyCore.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../Storage/BountyStorageCore.sol';
    | 
    | /// @title BountyCore
    | /// @author FlacoJones
    | /// @notice Shared methods common to all bounty types
    | /// @dev BountyCore -> BountyStorageCore -> Core Dependencies (OZ + Custom)
    | abstract contract BountyCore is BountyStorageCore {
    |     using SafeERC20Upgradeable for IERC20Upgradeable;
    |     using AddressUpgradeable for address payable;
    |     using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
    | 
    |     /// @notice Creates a deposit and transfers tokens from msg.sender to this contract
    |     /// @param _funder The funder's address
    |     /// @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)
    |     /// @param _volume The volume of token to transfer
    |     /// @param _expiration The duration until the deposit becomes refundable
    |     /// @return (depositId, volumeReceived) Returns the deposit id and the amount transferred to bounty
    |     function receiveFunds(
    |         address _funder,
    |         address _tokenAddress,
    |         uint256 _volume,
    |         uint256 _expiration
    |     )
    |         external
    |         payable
    |         virtual
    |         onlyDepositManager
    |         nonReentrant
    |         returns (bytes32, uint256)
    |     {
    |         require(_volume != 0, Errors.ZERO_VOLUME_SENT);
    |         require(_expiration > 0, Errors.EXPIRATION_NOT_GREATER_THAN_ZERO);
    |         require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);
    | 
    |         bytes32 depositId = _generateDepositId();
    | 
    |         uint256 volumeReceived;
    |         if (_tokenAddress == address(0)) {
    |             volumeReceived = msg.value;
    |         } else {
    |             volumeReceived = _receiveERC20(_tokenAddress, _funder, _volume);
    |         }
    | 
    |         funder[depositId] = _funder;
    |         tokenAddress[depositId] = _tokenAddress;
    |         volume[depositId] = volumeReceived;
    |         depositTime[depositId] = block.timestamp;
    |         expiration[depositId] = _expiration;
    |         isNFT[depositId] = false;
    | 
    |         deposits.push(depositId);
    |         tokenAddresses.add(_tokenAddress);
    | 
    |         return (depositId, volumeReceived);
    |     }
    | 
    |     /// @notice Transfers volume of deposit or NFT of deposit from bounty to funder
    |     /// @param _depositId The deposit to refund
    |     /// @param _funder The initial funder of the deposit
    |     /// @param _volume The volume to be refunded (only relevant if deposit is not an NFT, otherwise is zero)
    |     function refundDeposit(
    |         bytes32 _depositId,
    |         address _funder,
    |         uint256 _volume
    |     ) external virtual onlyDepositManager nonReentrant {
    |         require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);
    |         require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);
    |         require(
    |             block.timestamp >= depositTime[_depositId] + expiration[_depositId],
    |             Errors.PREMATURE_REFUND_REQUEST
    |         );
    | 
    |         refunded[_depositId] = true;
    | 
    |         if (tokenAddress[_depositId] == address(0)) {
    |             _transferProtocolToken(funder[_depositId], _volume);
    |         } else if (isNFT[_depositId]) {
    |             _transferNft(
    |                 tokenAddress[_depositId],
    |                 funder[_depositId],
    |                 tokenId[_depositId]
    |             );
    |         } else {
    |             _transferERC20(
    |                 tokenAddress[_depositId],
    |                 funder[_depositId],
    |                 _volume
    |             );
    |         }
    |     }
    | 
    |     /// @notice Extends deposit duration
    |     /// @param _depositId The deposit to extend
    |     /// @param _seconds Number of seconds to extend deposit
    |     /// @param _funder The initial funder of the deposit
    |     function extendDeposit(
    |         bytes32 _depositId,
    |         uint256 _seconds,
    |         address _funder
    |     ) external virtual onlyDepositManager nonReentrant returns (uint256) {
    |         require(status == OpenQDefinitions.OPEN, Errors.CONTRACT_IS_CLOSED);
    |         require(!refunded[_depositId], Errors.DEPOSIT_ALREADY_REFUNDED);
    |         require(funder[_depositId] == _funder, Errors.CALLER_NOT_FUNDER);
    | 
    |         if (
    |             block.timestamp > depositTime[_depositId] + expiration[_depositId]
    |         ) {
    |             expiration[_depositId] =
    |                 block.timestamp -
    |                 depositTime[_depositId] +
    |                 _seconds;
    |         } else {
    |             expiration[_depositId] = expiration[_depositId] + _seconds;
    |         }
    | 
    |         return expiration[_depositId];
    |     }
    | 
    |     /// @notice Transfers NFT from bounty address to _payoutAddress
    |     /// @param _payoutAddress The destination address for the NFT
    |     /// @param _depositId The payout address of the bounty
    |     function claimNft(address _payoutAddress, bytes32 _depositId)
    |         external
    |         virtual
    |         onlyClaimManager
    |         nonReentrant
    |     {
    |         _transferNft(
    |             tokenAddress[_depositId],
    |             _payoutAddress,
    |             tokenId[_depositId]
    |         );
    |     }
    | 
    |     /// @notice Sets the funding goal
    |     /// @param _fundingToken Token address for funding goal
    |     /// @param _fundingGoal Token volume for funding goal
    |     function setFundingGoal(address _fundingToken, uint256 _fundingGoal)
    |         external
    |         virtual
    |         onlyOpenQ
    |     {
    |         fundingGoal = _fundingGoal;
    |         fundingToken = _fundingToken;
    |         hasFundingGoal = true;
    |     }
    | 
    |     /// @notice Whether or not KYC is required to fund and claim the bounty
    |     /// @param _kycRequired Whether or not KYC is required to fund and claim the bounty
    |     function setKycRequired(bool _kycRequired) external virtual onlyOpenQ {
    |         kycRequired = _kycRequired;
    |     }
    | 
    |     /// @notice Whether or not the Bounty is invoiceRequired
    |     /// @param _invoiceRequired Whether or not the Bounty is invoiceRequired
    |     function setInvoiceRequired(bool _invoiceRequired)
    |         external
    |         virtual
    |         onlyOpenQ
    |     {
    |         invoiceRequired = _invoiceRequired;
    |     }
    | 
    |     /// @notice Whether or not KYC is required to fund and claim the bounty
    |     /// @param _supportingDocumentsRequired Whether or not KYC is required to fund and claim the bounty
    |     function setSupportingDocumentsRequired(bool _supportingDocumentsRequired)
    |         external
    |         virtual
    |         onlyOpenQ
    |     {
    |         supportingDocumentsRequired = _supportingDocumentsRequired;
    |     }
    | 
    |     /// @notice Transfers _volume of both ERC20 or protocol token to _payoutAddress
    |     /// @param _tokenAddress Address of an ERC20 or Zero Address for protocol token
    |     /// @param _volume Volume to transfer
    |     /// @param _payoutAddress Destination address
    |     function _transferToken(
    |         address _tokenAddress,
    |         uint256 _volume,
    |         address _payoutAddress
    |     ) internal virtual {
    |         if (_tokenAddress == address(0)) {
    |             _transferProtocolToken(_payoutAddress, _volume);
    |         } else {
    |             _transferERC20(_tokenAddress, _payoutAddress, _volume);
    |         }
    |     }
    | 
    |     /// @notice Receives _volume of ERC20 at _tokenAddress from _funder to bounty address
    |     /// @param _tokenAddress The ERC20 token address
    |     /// @param _funder The funder of the bounty
    |     /// @param _volume The volume of token to transfer
    |     function _receiveERC20(
    |         address _tokenAddress,
    |         address _funder,
    |         uint256 _volume
    |     ) internal virtual returns (uint256) {
    |         uint256 balanceBefore = getERC20Balance(_tokenAddress);
    |         IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);
    |         token.safeTransferFrom(_funder, address(this), _volume);
    |         uint256 balanceAfter = getERC20Balance(_tokenAddress);
    |         require(
    |             balanceAfter >= balanceBefore,
    |             Errors.TOKEN_TRANSFER_IN_OVERFLOW
    |         );
    | 
    |         //// The reason we take the balanceBefore and balanceAfter rather than the raw volume
    |         /// is because certain ERC20 contracts ( e.g. USDT) take fees on transfers.
    |         /// Therefore the volume received after transferFrom can be lower than the raw volume sent by the sender
    |         return balanceAfter - balanceBefore;
    |     }
    | 
    |     /// @notice Transfers _volume of ERC20 at _tokenAddress from bounty address to _funder
    |     /// @param _tokenAddress The ERC20 token address
    |     /// @param _payoutAddress The destination address of the funds
    |     /// @param _volume The volume of token to transfer
    |     function _transferERC20(
    |         address _tokenAddress,
    |         address _payoutAddress,
    |         uint256 _volume
    |     ) internal virtual {
    |         IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);
    |         token.safeTransfer(_payoutAddress, _volume);
    |     }
    | 
    |     /// @notice Transfers _volume of protocol token from bounty address to _payoutAddress
    |     /// @param _payoutAddress The destination address of the funds
    |     /// @param _volume The volume of token to transfer
    |     function _transferProtocolToken(address _payoutAddress, uint256 _volume)
    |         internal
    |         virtual
    |     {
    |         payable(_payoutAddress).sendValue(_volume);
    |     }
    | 
    |     /// @notice Receives NFT of _tokenId on _tokenAddress from _funder to bounty address
    |     /// @param _tokenAddress The ERC721 token address
    |     /// @param _sender The sender of the NFT
    |     /// @param _tokenId The tokenId
    |     function _receiveNft(
    |         address _tokenAddress,
    |         address _sender,
    |         uint256 _tokenId
    |     ) internal virtual {
    |         IERC721Upgradeable nft = IERC721Upgradeable(_tokenAddress);
    |         nft.safeTransferFrom(_sender, address(this), _tokenId);
    |     }
    | 
    |     /// @notice Transfers NFT of _tokenId on _tokenAddress from bounty address to _payoutAddress
    |     /// @param _tokenAddress The ERC721 token address
    |     /// @param _payoutAddress The sender of the NFT
    |     /// @param _tokenId The tokenId
    |     function _transferNft(
    |         address _tokenAddress,
    |         address _payoutAddress,
    |         uint256 _tokenId
    |     ) internal virtual {
    |         IERC721Upgradeable nft = IERC721Upgradeable(_tokenAddress);
    |         nft.safeTransferFrom(address(this), _payoutAddress, _tokenId);
    |     }
    | 
    |     /// @notice Generates a unique deposit ID from bountyId and the current length of deposits
    |     function _generateDepositId() internal view virtual returns (bytes32) {
    |         return keccak256(abi.encode(bountyId, deposits.length));
    |     }
    | 
    |     /// TRANSFER HELPERS
    | 
    |     /// @notice Returns token balance for both ERC20 or protocol token
    |     /// @param _tokenAddress Address of an ERC20 or Zero Address for protocol token
    |     function getTokenBalance(address _tokenAddress)
    |         public
    |         view
    |         virtual
    |         returns (uint256)
    |     {
    |         if (_tokenAddress == address(0)) {
    |             return address(this).balance;
    |         } else {
    |             return getERC20Balance(_tokenAddress);
    |         }
    |     }
    | 
    |     /// @notice Returns the ERC20 balance for this bounty address
    |     /// @param _tokenAddress The ERC20 token address
    |     /// @return balance The ERC20 balance for this bounty address
    |     function getERC20Balance(address _tokenAddress)
    |         public
    |         view
    |         virtual
    |         returns (uint256 balance)
    |     {
    |         IERC20Upgradeable token = IERC20Upgradeable(_tokenAddress);
    |         return token.balanceOf(address(this));
    |     }
    | 
    |     /// @notice Returns an array of all deposits (ERC20, protocol token, and NFT) for this bounty
    |     /// @return deposits The array of deposits including ERC20, protocol token, and NFT
    |     function getDeposits() external view virtual returns (bytes32[] memory) {
    |         return deposits;
    |     }
    | 
    |     /// @notice Returns an array of ONLY NFT deposits for this bounty
    |     /// @return nftDeposits The array of NFT deposits
    |     function getNftDeposits() external view virtual returns (bytes32[] memory) {
    |         return nftDeposits;
    |     }
    | 
    |     /// @notice Returns an array of all ERC20 token addresses which have funded this bounty
    |     /// @return tokenAddresses An array of all ERC20 token addresses which have funded this bounty
    |     function getTokenAddresses()
    |         public
    |         view
    |         virtual
    |         returns (address[] memory)
    |     {
    |         return tokenAddresses.values();
    |     }
    | 
    |     /// @notice Returns the total number of unique tokens deposited on the bounty
    |     /// @return tokenAddressesCount The length of the array of all ERC20 token addresses which have funded this bounty
    |     function getTokenAddressesCount() external view virtual returns (uint256) {
    |         return tokenAddresses.values().length;
    |     }
    | 
    |     /// @notice Returns the amount of locked tokens (of a specific token) on a bounty address, only available for claims but not for refunds
    |     /// @param _depositId The depositId that determines which token is being looked at
    |     /// @return uint256
    |     function getLockedFunds(address _depositId)
    |         public
    |         view
    |         virtual
    |         returns (uint256)
    |     {
    |         uint256 lockedFunds;
    |         bytes32[] memory depList = this.getDeposits();
    |         for (uint256 i = 0; i < depList.length; i++) {
    |             if (
    |                 block.timestamp <
    |                 depositTime[depList[i]] + expiration[depList[i]] &&
    |                 tokenAddress[depList[i]] == _depositId
    |             ) {
    |                 lockedFunds += volume[depList[i]];
    |             }
    |         }
    | 
    |         return lockedFunds;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Implementations/OngoingBountyV1.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../Storage/OngoingBountyStorage.sol';
    | 
    | /// @title OngoingBountyV1
    | /// @author FlacoJones
    | /// @notice Bounty implementation for multiple contributor, multiple + fixed payout scenarios (e.g. 500 USDC for every submission)
    | /// @dev OngoingBountyV1 -> OngoingBountyStorageV1 -> BountyCore -> BountyStorageCore -> Core Dependencies (OZ + Custom)
r   | /// @dev Do not add any new storage variables here. Put them in a TieredPercentageBountyStorageV# and release new implementation
    | contract OngoingBountyV1 is OngoingBountyStorageV1 {
    |     using SafeERC20Upgradeable for IERC20Upgradeable;
    |     using AddressUpgradeable for address payable;
    |     using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
    | 
    |     constructor() {}
    | 
    |     /// @notice Initializes a bounty proxy with initial state
    |     /// @param _bountyId The unique bounty identifier
    |     /// @param _issuer The sender of the mint bounty transaction
    |     /// @param _organization The organization associated with the bounty
    |     /// @param _openQ The OpenQProxy address
    |     /// @param _claimManager The Claim Manager proxy address
    |     /// @param _depositManager The Deposit Manager proxy address
    |     /// @param _operation The ABI encoded data determining the type of bounty being initialized and associated data
    |     /// @dev see IBountyCore.initialize.(_operation) for _operation ABI encoding schema for ONGOING
    |     function initialize(
    |         string memory _bountyId,
    |         address _issuer,
    |         string memory _organization,
    |         address _openQ,
    |         address _claimManager,
    |         address _depositManager,
    |         OpenQDefinitions.InitOperation memory _operation
    |     ) external initializer {
    |         require(bytes(_bountyId).length != 0, Errors.NO_EMPTY_BOUNTY_ID);
    |         require(bytes(_organization).length != 0, Errors.NO_EMPTY_ORGANIZATION);
    | 
    |         __ReentrancyGuard_init();
    | 
    |         __OnlyOpenQ_init(_openQ);
    |         __ClaimManagerOwnable_init(_claimManager);
    |         __DepositManagerOwnable_init(_depositManager);
    | 
    |         bountyId = _bountyId;
    |         issuer = _issuer;
    |         organization = _organization;
    |         bountyCreatedTime = block.timestamp;
    |         nftDepositLimit = 5;
    | 
    |         (
    |             address _payoutTokenAddress,
    |             uint256 _payoutVolume,
    |             bool _hasFundingGoal,
    |             address _fundingToken,
    |             uint256 _fundingGoal,
    |             bool _invoiceRequired,
    |             bool _kycRequired,
    |             bool _supportingDocumentsRequired,
    |             string memory _issuerExternalUserId,
    |             ,
    | 
    |         ) = abi.decode(
    |                 _operation.data,
    |                 (
    |                     address,
    |                     uint256,
    |                     bool,
    |                     address,
    |                     uint256,
    |                     bool,
    |                     bool,
    |                     bool,
    |                     string,
    |                     string,
    |                     string
    |                 )
    |             );
    | 
    |         bountyType = OpenQDefinitions.ONGOING;
    |         payoutTokenAddress = _payoutTokenAddress;
    |         payoutVolume = _payoutVolume;
    |         hasFundingGoal = _hasFundingGoal;
    |         fundingToken = _fundingToken;
    |         fundingGoal = _fundingGoal;
    |         invoiceRequired = _invoiceRequired;
    |         kycRequired = _kycRequired;
    |         supportingDocumentsRequired = _supportingDocumentsRequired;
    |         issuerExternalUserId = _issuerExternalUserId;
    |     }
    | 
    |     /// @notice Transfers a payout amount of an ongoing bounty to claimant for claimant asset
    |     /// @param _payoutAddress The destination address for the funds
    |     /// @param _closerData ABI-encoded data of the claimant and claimant asset
    |     /// @dev see IBountyCore.claimOngoingPayout.(_closerData) for _closerData ABI encoding schema
    |     function claimOngoingPayout(
    |         address _payoutAddress,
    |         bytes calldata _closerData
    |     ) external onlyClaimManager nonReentrant returns (address, uint256) {
    |         (, string memory claimant, , string memory claimantAsset) = abi.decode(
    |             _closerData,
    |             (address, string, address, string)
    |         );
    | 
    |         bytes32 _claimId = generateClaimId(claimant, claimantAsset);
    | 
    |         claimId[_claimId] = true;
    |         claimIds.push(_claimId);
    | 
    |         _transferToken(payoutTokenAddress, payoutVolume, _payoutAddress);
    |         return (payoutTokenAddress, payoutVolume);
    |     }
    | 
    |     /// @notice Similar to close() for single priced bounties. Stops all withdrawls.
    |     /// @param _closer Address of the closer
    |     function closeOngoing(address _closer) external onlyOpenQ {
    |         require(
    |             status == OpenQDefinitions.OPEN,
    |             Errors.CONTRACT_ALREADY_CLOSED
    |         );
    |         require(_closer == issuer, Errors.CALLER_NOT_ISSUER);
    | 
    |         status = OpenQDefinitions.CLOSED;
    |         bountyClosedTime = block.timestamp;
    |     }
    | 
    |     /// @notice Receives an NFT for this contract
    |     /// @param _sender Sender of the NFT
    |     /// @param _tokenAddress NFT token address
    |     /// @param _tokenId NFT token id
    |     /// @param _expiration How long before this deposit becomes refundable
    |     /// @return bytes32 the deposit id
    |     function receiveNft(
    |         address _sender,
    |         address _tokenAddress,
    |         uint256 _tokenId,
    |         uint256 _expiration,
    |         bytes calldata
    |     ) external onlyDepositManager nonReentrant returns (bytes32) {
    |         require(
    |             nftDeposits.length < nftDepositLimit,
    |             Errors.NFT_DEPOSIT_LIMIT_REACHED
    |         );
    |         require(_expiration > 0, Errors.EXPIRATION_NOT_GREATER_THAN_ZERO);
    |         _receiveNft(_tokenAddress, _sender, _tokenId);
    | 
    |         bytes32 depositId = _generateDepositId();
    | 
    |         funder[depositId] = _sender;
    |         tokenAddress[depositId] = _tokenAddress;
    |         depositTime[depositId] = block.timestamp;
    |         tokenId[depositId] = _tokenId;
    |         expiration[depositId] = _expiration;
    |         isNFT[depositId] = true;
    | 
    |         deposits.push(depositId);
    |         nftDeposits.push(depositId);
    | 
    |         return depositId;
    |     }
    | 
    |     /// @notice Sets the payout for an ongoing bounty
    |     /// @param _payoutTokenAddress Sets payout token address
    |     /// @param _payoutVolume Sets payout token volume
    |     function setPayout(address _payoutTokenAddress, uint256 _payoutVolume)
    |         external
    |         onlyOpenQ
    |     {
    |         payoutTokenAddress = _payoutTokenAddress;
    |         payoutVolume = _payoutVolume;
    |     }
    | 
    |     /// @notice Whether or not invoice has been completed
    |     /// @param _data ABI encoded data
    |     /// @dev see IBountyCore.setInvoiceComplete.(_data) for _data ABI encoding schema
    |     function setInvoiceComplete(bytes calldata _data) external onlyOpenQ {
    |         (bytes32 _claimId, bool _invoiceComplete) = abi.decode(
    |             _data,
    |             (bytes32, bool)
    |         );
    |         invoiceComplete[_claimId] = _invoiceComplete;
    |         invoiceCompleteClaimIds.push(_claimId);
    |     }
    | 
    |     /// @notice Whether or not supporting documents have been completed
    |     /// @param _data ABI encoded data
    |     /// @dev see IBountyCore.setSupportingDocumentsComplete.(_data) for _data ABI encoding schema
    |     function setSupportingDocumentsComplete(bytes calldata _data)
    |         external
    |         onlyOpenQ
    |     {
    |         (bytes32 _claimId, bool _supportingDocumentsComplete) = abi.decode(
    |             _data,
    |             (bytes32, bool)
    |         );
    |         supportingDocumentsComplete[_claimId] = _supportingDocumentsComplete;
    |         supportingDocumentsCompleteClaimIds.push(_claimId);
    |     }
    | 
    |     /// @notice Returns the claimIds which have completed supporting documents
    |     /// @return Documents the return variables of a contract’s function state variable
    |     /// @dev We return from all IBountyCore.getSupportingDocumentsComplete() as bytes to accomodate different return types
    |     /// @dev _data (bytes32[])
    |     /// @dev _data (supportingDocumentsCompleteClaimIds)
    |     function getSupportingDocumentsComplete()
    |         external
    |         view
    |         returns (bytes memory)
    |     {
    |         return abi.encode(supportingDocumentsCompleteClaimIds);
    |     }
    | 
    |     /// @notice Returns the claimIds which have completed supporting documents
    |     /// @return Documents the return variables of a contract’s function state variable
    |     /// @dev We return from all IBountyCore.getInvoiceComplete() as bytes to accomodate different return types
    |     /// @dev _data (bytes32[])
    |     /// @dev _data (invoiceCompleteClaimIds)
    |     function getInvoiceComplete() external view returns (bytes memory) {
    |         return abi.encode(invoiceCompleteClaimIds);
    |     }
    | 
    |     /// @notice Returns all claimIds
    |     /// @return Array of bytes32 claim ids
    |     function getClaimIds() public view returns (bytes32[] memory) {
    |         return claimIds;
    |     }
    | 
    |     /// @notice Generates a unique claimant ID from user and asset
    |     function generateClaimId(
    |         string memory claimant,
    |         string memory claimantAsset
    |     ) public pure virtual returns (bytes32) {
    |         return keccak256(abi.encode(claimant, claimantAsset));
    |     }
    | 
    |     /// @notice receive() method to accept protocol tokens
    |     receive() external payable {
    |         revert(
    |             'Cannot send Ether directly to boutny contract. Please use the BountyV1.receiveFunds() method.'
    |         );
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Implementations/TieredBountyCore.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../Storage/TieredBountyStorageCore.sol';
    | 
    | /// @title TieredBountyCore
    | /// @author FlacoJones
    | /// @notice Shared methods common to all tiered bounty types (tier meaning multiple payout levels, e.g. 1st, 2nd, 3rd)
    | /// @dev TieredBountyCore -> TieredBountyStorageCore -> BountyCore -> BountyStorageCore -> Core Dependencies (OZ + Custom)
    | abstract contract TieredBountyCore is TieredBountyStorageCore {
    |     /// @notice Receives an NFT for this contract
    |     /// @param _sender Sender of the NFT
    |     /// @param _tokenAddress NFT token address
    |     /// @param _tokenId NFT token id
    |     /// @param _expiration How long before this deposit becomes refundable
    |     /// @param _data ABI encoded data (unused in this case)
    |     /// @return bytes32 the deposit id
    |     function receiveNft(
    |         address _sender,
    |         address _tokenAddress,
    |         uint256 _tokenId,
    |         uint256 _expiration,
    |         bytes calldata _data
    |     ) external override onlyDepositManager nonReentrant returns (bytes32) {
    |         require(
    |             nftDeposits.length < nftDepositLimit,
    |             Errors.NFT_DEPOSIT_LIMIT_REACHED
    |         );
    |         require(_expiration > 0, Errors.EXPIRATION_NOT_GREATER_THAN_ZERO);
    |         _receiveNft(_tokenAddress, _sender, _tokenId);
    | 
    |         bytes32 depositId = _generateDepositId();
    | 
    |         funder[depositId] = _sender;
    |         tokenAddress[depositId] = _tokenAddress;
    |         depositTime[depositId] = block.timestamp;
    |         tokenId[depositId] = _tokenId;
    |         expiration[depositId] = _expiration;
    |         isNFT[depositId] = true;
    | 
    |         uint256 _tier = abi.decode(_data, (uint256));
    |         tier[depositId] = _tier;
    | 
    |         deposits.push(depositId);
    |         nftDeposits.push(depositId);
    | 
    |         return depositId;
    |     }
    | 
    |     /// @notice Sets tierClaimed to true for the given tier
    |     /// @param _tier The tier being claimed
    |     function setTierClaimed(uint256 _tier) external onlyClaimManager {
    |         tierClaimed[_tier] = true;
    |     }
    | 
    |     /// @notice Sets a winner for a particular tier
    |     /// @param _tier The tier they won
    |     /// @param _winner The external UUID (e.g. an OpenQ User UUID) that won this tier
    |     function setTierWinner(string memory _winner, uint256 _tier)
    |         external
    |         onlyOpenQ
    |     {
    |         tierWinners[_tier] = _winner;
    |     }
    | 
    |     /// @notice Whether or not invoice has been completed
    |     /// @param _data ABI encoded data
    |     /// @dev see IBountyCore.setInvoiceComplete.(_data) for _data ABI encoding schema
    |     function setInvoiceComplete(bytes calldata _data) external onlyOpenQ {
    |         (uint256 _tier, bool _invoiceComplete) = abi.decode(
    |             _data,
    |             (uint256, bool)
    |         );
    |         invoiceComplete[_tier] = _invoiceComplete;
    |     }
    | 
    |     /// @notice Whether or not supporting documents have been completed
    |     /// @param _data ABI encoded data
    |     /// @dev see IBountyCore.setSupportingDocumentsComplete.(_data) for _data ABI encoding schema
    |     function setSupportingDocumentsComplete(bytes calldata _data)
    |         external
    |         onlyOpenQ
    |     {
    |         (uint256 _tier, bool _supportingDocumentsComplete) = abi.decode(
    |             _data,
    |             (uint256, bool)
    |         );
    |         supportingDocumentsComplete[_tier] = _supportingDocumentsComplete;
    |     }
    | 
    |     /// @notice Returns an array for the payoutSchedule
    |     /// @return payoutSchedule An array containing the percentage to pay to [1st, 2nd, etc.] place
    |     function getPayoutSchedule() external view returns (uint256[] memory) {
    |         return payoutSchedule;
    |     }
    | 
    |     /// @notice Returns array of winners
    |     /// @return An array of the external ids (e.g. OpenQ User UUIDs) of the tier winners
    |     function getTierWinners() external view returns (string[] memory) {
    |         return tierWinners;
    |     }
    | 
    |     /// @notice Returns array of invoice complete
    |     /// @return An array of the booleans for each tier, true or false for if invoices have been completed for that tier
    |     /// @dev We return from all IBountyCore.getSupportingDocumentsComplete() as bytes to accomodate different return types
    |     /// @dev _data (bool[])
    |     /// @dev _data (invoiceComplete)
    |     function getInvoiceComplete() external view returns (bytes memory) {
    |         return abi.encode(invoiceComplete);
    |     }
    | 
    |     /// @notice Returns array of supporting documents complete
    |     /// @return An array of the booleans for each tier, true or false for if supporting documents have been completed for that tier
    |     /// @dev We return from all IBountyCore.getSupportingDocumentsComplete() as bytes to accomodate different return types
    |     /// @dev _data (bool[])
    |     /// @dev _data (supportingDocumentsComplete)
    |     function getSupportingDocumentsComplete()
    |         external
    |         view
    |         returns (bytes memory)
    |     {
    |         return abi.encode(supportingDocumentsComplete);
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Implementations/TieredFixedBountyV1.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../Storage/TieredFixedBountyStorage.sol';
    | 
    | /// @title TieredFixedBountyV1
    | /// @author FlacoJones
    | /// @notice Bounty implementation for tiered bounties with fixed amount for each tier
    | /// @dev TieredFixedBountyV1 -> TieredFixedBountyStorageV1 -> TieredBountyCore -> TieredBountyStorageCore -> BountyCore -> BountyStorageCore -> (Third Party Deps + Custom )
r   | /// @dev Do not add any new storage variables here. Put them in a TieredPercentageBountyStorageV# and release new implementation
    | contract TieredFixedBountyV1 is TieredFixedBountyStorageV1 {
    |     using SafeERC20Upgradeable for IERC20Upgradeable;
    |     using AddressUpgradeable for address payable;
    |     using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
    | 
    |     constructor() {}
    | 
    |     /// @notice Initializes a bounty proxy with initial state
    |     /// @param _bountyId The unique bounty identifier
    |     /// @param _issuer The sender of the mint bounty transaction
    |     /// @param _organization The organization associated with the bounty
    |     /// @param _openQ The OpenQProxy address
    |     /// @param _claimManager The Claim Manager proxy address
    |     /// @param _depositManager The Deposit Manager proxy address
    |     /// @param _operation The ABI encoded data determining the type of bounty being initialized and associated data
    | 		/// @dev see IBountyCore.initialize.(_operation) for _operation ABI encoding schema for TIERED FIXED
    |     function initialize(
    |         string memory _bountyId,
    |         address _issuer,
    |         string memory _organization,
    |         address _openQ,
    |         address _claimManager,
    |         address _depositManager,
    |         OpenQDefinitions.InitOperation memory _operation
    |     ) external initializer {
    |         require(bytes(_bountyId).length != 0, Errors.NO_EMPTY_BOUNTY_ID);
    |         require(bytes(_organization).length != 0, Errors.NO_EMPTY_ORGANIZATION);
    | 
    |         __ReentrancyGuard_init();
    | 
    |         __OnlyOpenQ_init(_openQ);
    |         __ClaimManagerOwnable_init(_claimManager);
    |         __DepositManagerOwnable_init(_depositManager);
    | 
    |         bountyId = _bountyId;
    |         issuer = _issuer;
    |         organization = _organization;
    |         bountyCreatedTime = block.timestamp;
    |         nftDepositLimit = 5;
    | 
    |         (
    |             uint256[] memory _payoutSchedule,
    |             address _payoutTokenAddress,
    |             bool _invoiceRequired,
    |             bool _kycRequired,
    |             bool _supportingDocumentsRequired,
    |             string memory _issuerExternalUserId,
    |             ,
    | 
    |         ) = abi.decode(
    |                 _operation.data,
    |                 (
    |                     uint256[],
    |                     address,
    |                     bool,
    |                     bool,
    |                     bool,
    |                     string,
    |                     string,
    |                     string
    |                 )
    |             );
    | 
    |         bountyType = OpenQDefinitions.TIERED_FIXED;
    |         payoutSchedule = _payoutSchedule;
    | 				payoutTokenAddress = _payoutTokenAddress;
    |         invoiceRequired = _invoiceRequired;
    |         kycRequired = _kycRequired;
    |         supportingDocumentsRequired = _supportingDocumentsRequired;
    |         issuerExternalUserId = _issuerExternalUserId;
    | 
    |         // Initialize metadata arrays to same number of tiers
    |         tierWinners = new string[](_payoutSchedule.length);
    |         invoiceComplete = new bool[](_payoutSchedule.length);
    |         supportingDocumentsComplete = new bool[](_payoutSchedule.length);
    |     }
    | 
    |     /// @notice Transfers the fixed amount of balance associated with the tier
    |     /// @param _payoutAddress The destination address for the fund
    |     /// @param _tier The ordinal of the claimant (e.g. 1st place, 2nd place)
    |     function claimTieredFixed(address _payoutAddress, uint256 _tier)
    |         external
    |         onlyClaimManager
    |         nonReentrant
    |         returns (uint256)
    |     {
    |         require(
    |             bountyType == OpenQDefinitions.TIERED_FIXED,
    |             Errors.NOT_A_TIERED_FIXED_BOUNTY
    |         );
    |         require(!tierClaimed[_tier], Errors.TIER_ALREADY_CLAIMED);
    | 
    |         uint256 claimedBalance = payoutSchedule[_tier];
    | 
    |         _transferToken(payoutTokenAddress, claimedBalance, _payoutAddress);
    |         return claimedBalance;
    |     }
    | 
    |     /// @notice Similar to close() for single priced bounties. closeCompetition() freezes the current funds for the competition.
    |     function closeCompetition() external onlyClaimManager {
    |         require(
    |             status == OpenQDefinitions.OPEN,
    |             Errors.CONTRACT_ALREADY_CLOSED
    |         );
    | 
    |         status = OpenQDefinitions.CLOSED;
    |         bountyClosedTime = block.timestamp;
    |     }
    | 
    |     /// @notice Sets fundingGoal for bounty with id _bountyId
    |     /// @param _fundingToken The token address to be used for the funding goal
    |     /// @param _fundingGoal The volume of token to be used for the funding goal
    |     function setFundingGoal(address _fundingToken, uint256 _fundingGoal)
    |         external
    |         override
    |         onlyOpenQ
    |     {
    |         fundingGoal = _fundingGoal;
    |         fundingToken = _fundingToken;
    |         hasFundingGoal = true;
    | 
    |         payoutTokenAddress = _fundingToken;
    |     }
    | 
    |     /// @notice Sets the payout schedule
    |     /// @param _payoutSchedule An array of payout volumes for each tier
    |     /// @param _payoutTokenAddress The address of the token to be used for the payout
    |     function setPayoutScheduleFixed(
    |         uint256[] calldata _payoutSchedule,
    |         address _payoutTokenAddress
    |     ) external onlyOpenQ {
    |         require(
    |             bountyType == OpenQDefinitions.TIERED_FIXED,
    |             Errors.NOT_A_FIXED_TIERED_BOUNTY
    |         );
    |         payoutSchedule = _payoutSchedule;
    |         payoutTokenAddress = _payoutTokenAddress;
    | 
    |         // Resize metadata arrays and copy current members to new array
    |         // NOTE: If resizing to fewer tiers than previously, the final indexes will be removed
    |         string[] memory newTierWinners = new string[](payoutSchedule.length);
    |         bool[] memory newInvoiceComplete = new bool[](payoutSchedule.length);
    |         bool[] memory newSupportingDocumentsCompleted = new bool[](
    |             payoutSchedule.length
    |         );
    | 
    |         for (uint256 i = 0; i < tierWinners.length; i++) {
    |             newTierWinners[i] = tierWinners[i];
    |         }
    |         tierWinners = newTierWinners;
    | 
    |         for (uint256 i = 0; i < invoiceComplete.length; i++) {
    |             newInvoiceComplete[i] = invoiceComplete[i];
    |         }
    |         invoiceComplete = newInvoiceComplete;
    | 
    |         for (uint256 i = 0; i < supportingDocumentsComplete.length; i++) {
    |             newSupportingDocumentsCompleted[i] = supportingDocumentsComplete[i];
    |         }
    |         supportingDocumentsComplete = newSupportingDocumentsCompleted;
    |     }
    | 
    |     /// @notice receive() method to accept protocol tokens
    |     receive() external payable {
    |         revert(
    |             'Cannot send Ether directly to boutny contract. Please use the BountyV1.receiveFunds() method.'
    |         );
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Implementations/TieredPercentageBountyV1.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../Storage/TieredPercentageBountyStorage.sol';
    | 
    | /// @title TieredPercentageBountyV1
    | /// @notice TieredPercentageBountyV1 is a bounty implementation contract for single contributor, single payout circumstances
    | /// @dev TieredPercentageBountyV1 -> TieredPercentageBountyStorageV1 -> TieredBountyCore -> TieredBountyStorageCore -> (BountyCore -> BountyStorageCore) -> (Third Party Deps + Custom )
r   | /// @dev Do not add any new storage variables here. Put them in a TieredPercentageBountyStorageV# and release new implementation
    | contract TieredPercentageBountyV1 is TieredPercentageBountyStorageV1 {
    |     using SafeERC20Upgradeable for IERC20Upgradeable;
    |     using AddressUpgradeable for address payable;
    |     using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;
    | 
    |     constructor() {}
    | 
    |     /// @notice Initializes a bounty proxy with initial state
    |     /// @param _bountyId The unique bounty identifier
    |     /// @param _issuer The sender of the mint bounty transaction
    |     /// @param _organization The organization associated with the bounty
    |     /// @param _openQ The OpenQProxy address
    |     /// @param _claimManager The Claim Manager proxy address
    |     /// @param _depositManager The Deposit Manager proxy address
    |     /// @param _operation The ABI encoded data determining the type of bounty being initialized and associated data
    |     /// @dev see IBountyCore.initialize.(_operation) for _operation ABI encoding schema for TIERED PERCENTAGE
    |     function initialize(
    |         string memory _bountyId,
    |         address _issuer,
    |         string memory _organization,
    |         address _openQ,
    |         address _claimManager,
    |         address _depositManager,
    |         OpenQDefinitions.InitOperation memory _operation
    |     ) external initializer {
    |         require(bytes(_bountyId).length != 0, Errors.NO_EMPTY_BOUNTY_ID);
    |         require(bytes(_organization).length != 0, Errors.NO_EMPTY_ORGANIZATION);
    | 
    |         __ReentrancyGuard_init();
    | 
    |         __OnlyOpenQ_init(_openQ);
    |         __ClaimManagerOwnable_init(_claimManager);
    |         __DepositManagerOwnable_init(_depositManager);
    | 
    |         bountyId = _bountyId;
    |         issuer = _issuer;
    |         organization = _organization;
    |         bountyCreatedTime = block.timestamp;
    |         nftDepositLimit = 5;
    | 
    |         (
    |             uint256[] memory _payoutSchedule,
    |             bool _hasFundingGoal,
    |             address _fundingToken,
    |             uint256 _fundingGoal,
    |             bool _invoiceRequired,
    |             bool _kycRequired,
    |             bool _supportingDocumentsRequired,
    |             string memory _issuerExternalUserId,
    |             ,
    | 
    |         ) = abi.decode(
    |                 _operation.data,
    |                 (
    |                     uint256[],
    |                     bool,
    |                     address,
    |                     uint256,
    |                     bool,
    |                     bool,
    |                     bool,
    |                     string,
    |                     string,
    |                     string
    |                 )
    |             );
    | 
    |         uint256 sum;
    |         for (uint256 i = 0; i < _payoutSchedule.length; i++) {
    |             sum += _payoutSchedule[i];
    |         }
    |         require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);
    |         payoutSchedule = _payoutSchedule;
    | 
    |         bountyType = OpenQDefinitions.TIERED_PERCENTAGE;
    |         hasFundingGoal = _hasFundingGoal;
    |         fundingToken = _fundingToken;
    |         fundingGoal = _fundingGoal;
    |         invoiceRequired = _invoiceRequired;
    |         kycRequired = _kycRequired;
    |         supportingDocumentsRequired = _supportingDocumentsRequired;
    |         issuerExternalUserId = _issuerExternalUserId;
    | 
    |         // Initialize metadata arrays to same number of tiers
    |         tierWinners = new string[](_payoutSchedule.length);
    |         invoiceComplete = new bool[](_payoutSchedule.length);
    |         supportingDocumentsComplete = new bool[](_payoutSchedule.length);
    |     }
    | 
    |     /// @notice Transfers the tiered percentage of the token balance of _tokenAddress from bounty to _payoutAddress
    |     /// @param _payoutAddress The destination address for the fund
    |     /// @param _tier The ordinal of the claimant (e.g. 1st place, 2nd place)
    |     /// @param _tokenAddress The token address being claimed
    |     /// @return Volume of claimed token payout
    |     function claimTiered(
    |         address _payoutAddress,
    |         uint256 _tier,
    |         address _tokenAddress
    |     ) external onlyClaimManager nonReentrant returns (uint256) {
    |         require(
    |             bountyType == OpenQDefinitions.TIERED_PERCENTAGE,
    |             Errors.NOT_A_TIERED_BOUNTY
    |         );
    |         require(!tierClaimed[_tier], Errors.TIER_ALREADY_CLAIMED);
    | 
    |         uint256 claimedBalance = (payoutSchedule[_tier] *
    |             fundingTotals[_tokenAddress]) / 100;
    | 
    |         _transferToken(_tokenAddress, claimedBalance, _payoutAddress);
    |         return claimedBalance;
    |     }
    | 
    |     /// @notice Similar to close() for single priced bounties. closeCompetition() freezes the current funds for the competition.
    |     function closeCompetition() external onlyClaimManager {
    |         require(
    |             status == OpenQDefinitions.OPEN,
    |             Errors.CONTRACT_ALREADY_CLOSED
    |         );
    | 
    |         status = OpenQDefinitions.CLOSED;
    |         bountyClosedTime = block.timestamp;
    | 
    |         for (uint256 i = 0; i < getTokenAddresses().length; i++) {
    |             address _tokenAddress = getTokenAddresses()[i];
    |             fundingTotals[_tokenAddress] = getTokenBalance(_tokenAddress);
    |         }
    |     }
    | 
    |     /// @notice Sets the payout schedule
    |     /// @notice There is no tokenAddress needed here - payouts on percentage tiered bounties is a percentage of whatever is deposited on the contract
    |     /// @param _payoutSchedule An array of payout volumes for each tier
    |     function setPayoutSchedule(uint256[] calldata _payoutSchedule)
    |         external
    |         onlyOpenQ
    |     {
    |         require(
    |             bountyType == OpenQDefinitions.TIERED_PERCENTAGE,
    |             Errors.NOT_A_TIERED_BOUNTY
    |         );
    |         uint256 sum;
    |         for (uint256 i = 0; i < _payoutSchedule.length; i++) {
    |             sum += _payoutSchedule[i];
    |         }
    |         require(sum == 100, Errors.PAYOUT_SCHEDULE_MUST_ADD_TO_100);
    | 
    |         payoutSchedule = _payoutSchedule;
    | 
    |         // Resize metadata arrays and copy current members to new array
    |         // NOTE: If resizing to fewer tiers than previously, the final indexes will be removed
    |         string[] memory newTierWinners = new string[](payoutSchedule.length);
    |         bool[] memory newInvoiceComplete = new bool[](payoutSchedule.length);
    |         bool[] memory newSupportingDocumentsCompleted = new bool[](
    |             payoutSchedule.length
    |         );
    | 
    |         for (uint256 i = 0; i < tierWinners.length; i++) {
    |             newTierWinners[i] = tierWinners[i];
    |         }
    |         tierWinners = newTierWinners;
    | 
    |         for (uint256 i = 0; i < invoiceComplete.length; i++) {
    |             newInvoiceComplete[i] = invoiceComplete[i];
    |         }
    |         invoiceComplete = newInvoiceComplete;
    | 
    |         for (uint256 i = 0; i < supportingDocumentsComplete.length; i++) {
    |             newSupportingDocumentsCompleted[i] = supportingDocumentsComplete[i];
    |         }
    |         supportingDocumentsComplete = newSupportingDocumentsCompleted;
    |     }
    | 
    |     /// @notice receive() method to accept protocol tokens
    |     receive() external payable {
    |         revert(
    |             'Cannot send Ether directly to boutny contract. Please use the BountyV1.receiveFunds() method.'
    |         );
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Interfaces/IAtomicBounty.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import './IBountyCore.sol';
    | 
    | /// @title IAtomicBounty
    | /// @author FlacoJones
    | /// @notice Interface defining AtomicBounty specific methods
    | interface IAtomicBounty is IBountyCore {
    |     /// @notice Changes bounty status from 0 (OPEN) to 1 (CLOSED)
    |     /// @param _payoutAddress The closer of the bounty
    |     /// @param _closerData ABI-encoded data about the claimant and claimant asset
    |     /// @dev _closerData (address,string,address,string,uint256)
    |     /// @dev _closerData (bountyAddress, externalUserId, closer, claimantAsset, tier)
    |     function close(address _payoutAddress, bytes calldata _closerData) external;
    | 
    |     /// @notice Transfers full balance of _tokenAddress from bounty to _payoutAddress
    |     /// @param _tokenAddress ERC20 token address or Zero Address for protocol token
    |     /// @param _payoutAddress The destination address for the funds
    |     function claimBalance(address _payoutAddress, address _tokenAddress)
    |         external
    |         returns (uint256);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Interfaces/IBounty.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import './IAtomicBounty.sol';
    | import './IOngoingBounty.sol';
    | import './ITieredPercentageBounty.sol';
    | import './ITieredFixedBounty.sol';
    | 
    | /// @title IBounty
    | /// @author FlacoJones
    | /// @notice Interface aggregating all bounty type interfaces for use in OpenQ, ClaimManager and DepositManager
    | interface IBounty is
    |     IAtomicBounty,
    |     IOngoingBounty,
    |     ITieredPercentageBounty,
    |     ITieredFixedBounty
    | {
    | 
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Interfaces/IBountyCore.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../../Library/OpenQDefinitions.sol';
    | import '@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol';
    | 
    | /// @title IBountyCore
    | /// @author FlacoJones
    | /// @notice Interface defining BountyCore methods shared across all bounty types
    | interface IBountyCore {
    |     /// @notice Initializes a bounty proxy with initial state
    |     /// @param _bountyId The unique bounty identifier
    |     /// @param _issuer The sender of the mint bounty transaction
    |     /// @param _organization The organization associated with the bounty
    |     /// @param _openQ The OpenQProxy address
    |     /// @param _claimManager The Claim Manager proxy address
    |     /// @param _depositManager The Deposit Manager proxy address
    |     /// @param _operation The ABI encoded data determining the type of bounty being initialized and associated data
    |     /// @dev ATOMIC
    |     /// @dev _operation (bool,address,uint256,bool,bool,bool,string,string,string)
    |     /// @dev _operation (hasFundingGoal, fundingToken, fundingGoal, invoiceRequired, kycRequired, supportingDocumentsRequired, issuerExternalUserId, alternativeLogo, alternativeName)
    |     /// @dev ONGOING
    |     /// @dev _operation (address,uint256,bool,address,uint256,bool,bool,bool,string,string,string)
    |     /// @dev _operation (payoutTokenAddress, payoutVolume, hasFundingGoal, fundingToken, fundingGoal, invoiceRequired, kycRequired, supportingDocumentsRequired, issuerExternalUserId, alternativeName, alternativeLogo)
    |     /// @dev TIERED PERCENTAGE
    |     /// @dev _operation (uint256[],bool,address,uint256,bool,bool,bool,string,string,string)
    |     /// @dev _operation (payoutSchedule, hasFundingGoal, fundingToken, fundingGoal, invoiceRequired, kycRequired, supportingDocumentsRequired, issuerExternalUserId, alternativeName, alternativeLogo)
    |     /// @dev TIERED FIXED
    |     /// @dev _operation (uint256[],address,bool,bool,bool,string,string,string)
    |     /// @dev _operation (payoutSchedule, payoutTokenAddress, invoiceRequired, kycRequired, supportingDocumentsRequired, issuerExternalUserId, alternativeName, alternativeLogo)
    |     function initialize(
    |         string memory _bountyId,
    |         address _issuer,
    |         string memory _organization,
    |         address _openQ,
    |         address _claimManager,
    |         address _depositManager,
    |         OpenQDefinitions.InitOperation memory _operation
    |     ) external;
    | 
    |     /// @notice Creates a deposit and transfers tokens from msg.sender to this contract
    |     /// @param _funder The funder's address
    |     /// @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)
    |     /// @param _volume The volume of token to transfer
    |     /// @param _expiration The duration until the deposit becomes refundable
    |     /// @return (depositId, volumeReceived) Returns the deposit id and the amount transferred to bounty
    |     function receiveFunds(
    |         address _funder,
    |         address _tokenAddress,
    |         uint256 _volume,
    |         uint256 _expiration
    |     ) external payable returns (bytes32, uint256);
    | 
    |     /// @notice Receives an NFT for this contract
    |     /// @param _sender Sender of the NFT
    |     /// @param _tokenAddress NFT token address
    |     /// @param _tokenId NFT token id
    |     /// @param _expiration How long before this deposit becomes refundable
    |     /// @param _data ABI encoded data (unused in this case)
    |     /// @return bytes32 the deposit id
    |     /// @dev _data (TIERED): (uint256):(tier)
    |     /// @dev _data (ATOMIC): empty bytes array
    |     /// @dev _data (ONGOING): empty bytes array
    |     function receiveNft(
    |         address _sender,
    |         address _tokenAddress,
    |         uint256 _tokenId,
    |         uint256 _expiration,
    |         bytes calldata _data
    |     ) external returns (bytes32);
    | 
    |     /// @notice Transfers volume of deposit or NFT of deposit from bounty to funder
    |     /// @param _depositId The deposit to refund
    |     /// @param _funder The initial funder of the deposit
    |     /// @param _volume The volume to be refunded (only relevant if deposit is not an NFT, otherwise is zero)
    |     function refundDeposit(
    |         bytes32 _depositId,
    |         address _funder,
    |         uint256 _volume
    |     ) external;
    | 
    |     /// @notice Extends deposit duration
    |     /// @param _depositId The deposit to extend
    |     /// @param _seconds Number of seconds to extend deposit
    |     /// @param _funder The initial funder of the deposit
    |     function extendDeposit(
    |         bytes32 _depositId,
    |         uint256 _seconds,
    |         address _funder
    |     ) external returns (uint256);
    | 
    |     /// @notice Transfers NFT from bounty address to _payoutAddress
    |     /// @param _payoutAddress The destination address for the NFT
    |     /// @param _depositId The payout address of the bounty
    |     function claimNft(address _payoutAddress, bytes32 _depositId) external;
    | 
    |     /// @notice Sets the funding goal
    |     /// @param _fundingToken Token address for funding goal
    |     /// @param _fundingGoal Token volume for funding goal
    |     function setFundingGoal(address _fundingToken, uint256 _fundingGoal)
    |         external;
    | 
    |     /// @notice Whether or not KYC is required to fund and claim the bounty
    |     /// @param _kycRequired Whether or not KYC is required to fund and claim the bounty
    |     function setKycRequired(bool _kycRequired) external;
    | 
    |     /// @notice Whether or not the Bounty is invoiceRequired
    |     /// @param _invoiceRequired Whether or not the Bounty is invoiceRequired
    |     function setInvoiceRequired(bool _invoiceRequired) external;
    | 
    |     /// @notice Whether or not KYC is required to fund and claim the bounty
    |     /// @param _supportingDocumentsRequired Whether or not KYC is required to fund and claim the bounty
    |     function setSupportingDocumentsRequired(bool _supportingDocumentsRequired)
    |         external;
    | 
    |     /// @notice Whether or not invoice has been completed
    |     /// @param _data ABI encoded data
    |     /// @dev _data (ATOMIC): (bool):(invoiceComplete)
    |     /// @dev _data (TIERED): (uint256,bool):(tier,invoiceComplete)
    |     /// @dev _data (ONGOING): (bytes32,bool):(claimId, invoiceComplete)
    |     function setInvoiceComplete(bytes calldata _data) external;
    | 
    |     /// @notice Whether or not supporting documents have been completed
    |     /// @param _data ABI encoded data
    |     /// @dev _data (ATOMIC): (bool):(supportingDocumentsComplete)
    |     /// @dev _data (TIERED): (uint256,bool):(tier,supportingDocumentsComplete)
    |     /// @dev _data (ONGOING): (bytes32,bool):(claimId, supportingDocumentsComplete)
    |     function setSupportingDocumentsComplete(bytes calldata _data) external;
    | 
    |     /// @notice Generic method that returns the ABI encoded supporting documents completion data from all bounty types
    |     /// @dev See the getSupportingDocumentsComplete defined on each bounty type to see the encoding
    |     function getSupportingDocumentsComplete()
    |         external
    |         view
    |         returns (bytes memory);
    | 
    |     /// @notice Generic method that returns the ABI encoded invoice completion data from all bounty types
    |     /// @dev See the getInvoiceComplete defined on each bounty type to see the encoding
    |     function getInvoiceComplete() external view returns (bytes memory);
    | 
    |     /// @notice Returns token balance for both ERC20 or protocol token
    |     /// @param _tokenAddress Address of an ERC20 or Zero Address for protocol token
    |     function getTokenBalance(address _tokenAddress)
    |         external
    |         view
    |         returns (uint256);
    | 
    |     /// @notice Returns an array of all ERC20 token addresses which have funded this bounty
    |     /// @return tokenAddresses An array of all ERC20 token addresses which have funded this bounty
    |     function getTokenAddresses() external view returns (address[] memory);
    | 
    |     /// @notice Returns an array of ONLY NFT deposits for this bounty
    |     /// @return nftDeposits The array of NFT deposits
    |     function getNftDeposits() external view returns (bytes32[] memory);
    | 
    |     /// @notice Returns the amount of locked tokens (of a specific token) on a bounty address, only available for claims but not for refunds
    |     /// @param _depositId The depositId that determines which token is being looked at
    |     /// @return uint256
    |     function getLockedFunds(address _depositId) external view returns (uint256);
    | 
    |     /// @notice Returns the total number of unique tokens deposited on the bounty
    |     /// @return tokenAddressesCount The length of the array of all ERC20 token addresses which have funded this bounty
    |     function getTokenAddressesCount() external view returns (uint256);
    | 
    |     // PUBLIC GETTERS
    |     function bountyId() external view returns (string memory);
    | 
    |     function bountyCreatedTime() external view returns (uint256);
    | 
    |     function bountyClosedTime() external view returns (uint256);
    | 
    |     function issuer() external view returns (address);
    | 
    |     function organization() external view returns (string memory);
    | 
    |     function closer() external view returns (address);
    | 
    |     function status() external view returns (uint256);
    | 
    |     function nftDepositLimit() external view returns (uint256);
    | 
    |     function funder(bytes32) external view returns (address);
    | 
    |     function tokenAddress(bytes32) external view returns (address);
    | 
    |     function volume(bytes32) external view returns (uint256);
    | 
    |     function depositTime(bytes32) external view returns (uint256);
    | 
    |     function refunded(bytes32) external view returns (bool);
    | 
    |     function payoutAddress(bytes32) external view returns (address);
    | 
    |     function tokenId(bytes32) external view returns (uint256);
    | 
    |     function expiration(bytes32) external view returns (uint256);
    | 
    |     function isNFT(bytes32) external view returns (bool);
    | 
    |     function deposits(uint256) external view returns (bytes32);
    | 
    |     function nftDeposits(uint256) external view returns (bytes32);
    | 
    |     function closerData() external view returns (bytes memory);
    | 
    |     function bountyType() external view returns (uint256);
    | 
    |     function hasFundingGoal() external view returns (bool);
    | 
    |     function fundingToken() external view returns (address);
    | 
    |     function fundingGoal() external view returns (uint256);
    | 
    |     function invoiceRequired() external view returns (bool);
    | 
    |     function kycRequired() external view returns (bool);
    | 
    |     function supportingDocumentsRequired() external view returns (bool);
    | 
    |     function issuerExternalUserId() external view returns (string memory);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Interfaces/IOngoingBounty.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import './IBountyCore.sol';
    | 
    | /// @title IOngoingBounty
    | /// @author FlacoJones
    | /// @notice Interface defining OngoingBounty specific methods
    | interface IOngoingBounty is IBountyCore {
    |     /// @notice Sets the payout for an ongoing bounty
    |     /// @param _payoutTokenAddress Sets payout token address
    |     /// @param _payoutVolume Sets payout token volume
    |     function setPayout(address _payoutTokenAddress, uint256 _payoutVolume)
    |         external;
    | 
    |     /// @notice Transfers a payout amount of an ongoing bounty to claimant for claimant asset
    |     /// @param _payoutAddress The destination address for the funds
    |     /// @param _closerData ABI-encoded data of the claimant and claimant asset
    |     /// @dev _closerData (address,string,address,string,uint256)
    |     /// @dev _closerData (bountyAddress, externalUserId, closer, claimantAsset, tier)
    |     function claimOngoingPayout(
    |         address _payoutAddress,
    |         bytes calldata _closerData
    |     ) external returns (address, uint256);
    | 
    |     /// @notice Similar to close() for single priced bounties. Stops all withdrawls.
    |     /// @param _closer Address of the closer
    |     function closeOngoing(address _closer) external;
    | 
    |     function getClaimIds() external returns (bytes32[] memory);
    | 
    |     function generateClaimId(
    |         string memory claimant,
    |         string memory claimantAsset
    |     ) external pure returns (bytes32);
    | 
    |     function invoiceComplete(bytes32) external view returns (bool);
    | 
    |     function supportingDocumentsComplete(bytes32) external view returns (bool);
    | 
    |     function supportingDocumentsCompleteClaimIds()
    |         external
    |         view
    |         returns (bytes32[] memory);
    | 
    |     function invoiceCompleteClaimIds() external view returns (bytes32[] memory);
    | 
    |     // PUBLIC GETTERS
    |     function payoutTokenAddress() external view returns (address);
    | 
    |     function payoutVolume() external view returns (uint256);
    | 
    |     function claimId(bytes32) external view returns (bool);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Interfaces/ITieredBounty.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import './IBountyCore.sol';
    | 
    | /// @title ITieredBounty
    | /// @author FlacoJones
    | /// @notice Interface defining TieredBounty methods shared between TieredPercentageBounty and TieredFixedBounty
    | interface ITieredBounty is IBountyCore {
    |     /// @notice Sets a winner for a particular tier
    |     /// @param _tier The tier they won
    |     /// @param _winner The external UUID (e.g. an OpenQ User UUID) that won this tier
    |     function setTierWinner(string memory _winner, uint256 _tier) external;
    | 
    |     /// @notice Sets the payout schedule
    |     /// @param _payoutSchedule An array of payout volumes for each tier
    |     function setPayoutSchedule(uint256[] calldata _payoutSchedule) external;
    | 
    |     /// @notice Similar to close() for single priced bounties. closeCompetition() freezes the current funds for the competition.
    |     function closeCompetition() external;
    | 
    |     /// @notice Sets tierClaimed to true for the given tier
    |     /// @param _tier The tier being claimed
    |     function setTierClaimed(uint256 _tier) external;
    | 
    |     /// @notice Transfers the tiered percentage of the token balance of _tokenAddress from bounty to _payoutAddress
    |     /// @param _payoutAddress The destination address for the fund
    |     /// @param _tier The ordinal of the claimant (e.g. 1st place, 2nd place)
    |     /// @param _tokenAddress The token address being claimed
    |     function claimTiered(
    |         address _payoutAddress,
    |         uint256 _tier,
    |         address _tokenAddress
    |     ) external returns (uint256);
    | 
    |     // PUBLIC GETTERS
    |     function tierClaimed(uint256 _tier) external view returns (bool);
    | 
    |     function tierWinners(uint256) external view returns (string memory);
    | 
    |     function invoiceComplete(uint256) external view returns (bool);
    | 
    |     function supportingDocumentsComplete(uint256) external view returns (bool);
    | 
    |     function tier(bytes32) external view returns (uint256);
    | 
    |     function getPayoutSchedule() external view returns (uint256[] memory);
    | 
    |     function getTierWinners() external view returns (string[] memory);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Interfaces/ITieredFixedBounty.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import './IBountyCore.sol';
    | import './ITieredBounty.sol';
    | 
    | /// @title ITieredFixedBounty
    | /// @author FlacoJones
    | /// @notice Interface defining TieredFixedBounty specific methods
    | interface ITieredFixedBounty is IBountyCore, ITieredBounty {
    |     /// @notice Sets the payout schedule
    |     /// @param _payoutSchedule An array of payout volumes for each tier
    |     /// @param _payoutTokenAddress The address of the token to be used for the payout
    |     function setPayoutScheduleFixed(
    |         uint256[] calldata _payoutSchedule,
    |         address _payoutTokenAddress
    |     ) external;
    | 
    |     /// @notice Transfers the fixed amount of balance associated with the tier
    |     /// @param _payoutAddress The destination address for the fund
    |     /// @param _tier The ordinal of the claimant (e.g. 1st place, 2nd place)
    |     function claimTieredFixed(address _payoutAddress, uint256 _tier)
    |         external
    |         returns (uint256);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Interfaces/ITieredPercentageBounty.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import './IBountyCore.sol';
    | import './ITieredBounty.sol';
    | 
    | /// @title ITieredPercentageBounty
    | /// @author FlacoJones
    | /// @notice Interface defining TieredPercentageBounty specific methods
    | interface ITieredPercentageBounty is IBountyCore, ITieredBounty {
    |     /// @notice Sets the payout schedule
    |     /// @notice There is no tokenAddress needed here - payouts on percentage tiered bounties is a percentage of whatever is deposited on the contract
    |     /// @param _payoutSchedule An array of payout volumes for each tier
    |     function setPayoutSchedule(uint256[] calldata _payoutSchedule) external;
    | 
    |     /// @notice Transfers the tiered percentage of the token balance of _tokenAddress from bounty to _payoutAddress
    |     /// @param _payoutAddress The destination address for the fund
    |     /// @param _tier The ordinal of the claimant (e.g. 1st place, 2nd place)
    |     /// @param _tokenAddress The token address being claimed
    |     /// @return Volume of claimed token payout
    |     function claimTiered(
    |         address _payoutAddress,
    |         uint256 _tier,
    |         address _tokenAddress
    |     ) external returns (uint256);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Proxy/BountyBeacon.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol';
    | 
    | /// @title BountyBeacon
    | /// @author FlacoJones
r   | /// @notice UpgradeableBeacon holding the current bounty implementation referred to by all BeaconProxy bounties
    | contract BountyBeacon is UpgradeableBeacon {
    |     /// @notice Initializes an UpgradeableBeacon which will transmit the current implementation of Bounty to all BeaconProxy bounties
    |     /// @param _implementation The initial implementation of Bounty
    |     constructor(address _implementation) UpgradeableBeacon(_implementation) {}
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Storage/AtomicBountyStorage.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../Implementations/BountyCore.sol';
    | 
    | /// @title AtomicBountyStorageV1
    | /// @author FlacoJones
    | /// @notice Backwards compatible, append-only chain of storage contracts inherited by all AtomicBountyStorage implementations
    | /// @dev Add new variables for upgrades in a new, derived abstract contract that inherits from the previous storage contract version (see: https://forum.openzeppelin.com/t/to-inherit-version1-to-version2-or-to-copy-code-inheritance-order-from-version1-to-version2/28069)
    | abstract contract AtomicBountyStorageV1 is BountyCore {
    |     uint256 public constant VERSION_1 = 1;
    |     bool public invoiceComplete;
    |     bool public supportingDocumentsComplete;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Storage/BountyStorageCore.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';
    | import '@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol';
    | import '@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol';
    | import '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';
    | import '@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol';
    | import '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';
    | import '@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol';
    | 
    | import '../../OnlyOpenQ/OnlyOpenQ.sol';
    | import '../../ClaimManager/ClaimManagerOwnable.sol';
    | import '../../DepositManager/DepositManagerOwnable.sol';
    | import '../../Library/OpenQDefinitions.sol';
    | import '../../Library/Errors.sol';
    | 
    | import '../Interfaces/IBountyCore.sol';
    | 
    | /// @title BountyStorageCore
    | /// @author FlacoJones
    | /// @notice Backwards compatible, append-only chain of storage contracts inherited by all (Type)BountyStorage implementations
    | /// @dev Since this contract is deep in the bounty implementations' inheritance chain, no new methods can be added to it (see: https://forum.openzeppelin.com/t/to-inherit-version1-to-version2-or-to-copy-code-inheritance-order-from-version1-to-version2/28069)
    | abstract contract BountyStorageCore is
    |     IBountyCore,
    |     ReentrancyGuardUpgradeable,
    |     ERC721HolderUpgradeable,
    |     OnlyOpenQ,
    |     ClaimManagerOwnable,
    |     DepositManagerOwnable
    | {
    |     /// @notice Bounty data
    |     string public bountyId;
    |     uint256 public bountyCreatedTime;
    |     uint256 public bountyClosedTime;
    |     address public issuer;
    |     string public organization;
    |     address public closer;
    |     uint256 public status;
    |     uint256 public nftDepositLimit;
    | 
    |     /// @notice Deconstructed deposit struct
    |     mapping(bytes32 => address) public funder;
    |     mapping(bytes32 => address) public tokenAddress;
    |     mapping(bytes32 => uint256) public volume;
    |     mapping(bytes32 => uint256) public depositTime;
    |     mapping(bytes32 => bool) public refunded;
    |     mapping(bytes32 => address) public payoutAddress;
    |     mapping(bytes32 => uint256) public tokenId;
    |     mapping(bytes32 => uint256) public expiration;
    |     mapping(bytes32 => bool) public isNFT;
    | 
    |     /// @notice Array of depositIds
    |     bytes32[] public deposits;
    |     bytes32[] public nftDeposits;
    | 
    |     /// @notice Set of unique token address
    |     EnumerableSetUpgradeable.AddressSet internal tokenAddresses;
    | 
    |     /// @notice Data related to the closer of this bounty
    |     bytes public closerData;
    | 
    |     /// @notice The class/type of bounty (Single, Ongoing, or Tiered)
    |     /// @dev type is a reserved word in Solidity
    |     uint256 public bountyType;
    | 
    |     bool public hasFundingGoal;
    |     address public fundingToken;
    |     uint256 public fundingGoal;
    |     bool public invoiceRequired;
    |     bool public kycRequired;
    |     bool public supportingDocumentsRequired;
    |     string public issuerExternalUserId;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Storage/OngoingBountyStorage.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../Implementations/BountyCore.sol';
    | 
    | /// @title OngoingBountyStorageV1
    | /// @author FlacoJones
    | /// @notice Backwards compatible, append-only chain of storage contracts inherited by all OngoingBountyStorage implementations
    | /// @dev Add new variables for upgrades in a new, derived abstract contract that inherits from the previous storage contract version (see: https://forum.openzeppelin.com/t/to-inherit-version1-to-version2-or-to-copy-code-inheritance-order-from-version1-to-version2/28069)
    | abstract contract OngoingBountyStorageV1 is BountyCore {
    |     uint256 public constant VERSION_1 = 1;
    | 
    |     /// @notice Ongoing Bounties pay out the same amount set by the minter for each submission.
    |     /// @dev Only closed once minter explicitly closes
    |     address public payoutTokenAddress;
    |     uint256 public payoutVolume;
    | 
    |     /// @dev keccak256 hash of the claimant ID (GitHub ID) with the claimant asset ID (GitHub PR ID)
    |     mapping(bytes32 => bool) public claimId;
    | 
    |     // Keys of claims, can be used off-chain as an iterable to determine completed payouts
    |     bytes32[] public claimIds;
    | 
    |     // Quick lookup
    |     mapping(bytes32 => bool) public invoiceComplete;
    | 
    |     mapping(bytes32 => bool) public supportingDocumentsComplete;
    | 
    |     bytes32[] public supportingDocumentsCompleteClaimIds;
    | 
    |     bytes32[] public invoiceCompleteClaimIds;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Storage/TieredBountyStorageCore.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../Implementations/BountyCore.sol';
    | 
    | /// @title TieredBountyStorageCore
    | /// @author FlacoJones
    | /// @notice Backwards compatible, append-only chain of storage contracts inherited by all TieredBountyStorageCore implementations
    | /// @dev Since this contract is deep in the bounty implementations' inheritance chain, no new methods can be added to it (see: https://forum.openzeppelin.com/t/to-inherit-version1-to-version2-or-to-copy-code-inheritance-order-from-version1-to-version2/28069)
    | abstract contract TieredBountyStorageCore is BountyCore {
    |     uint256 public constant VERSION_1 = 1;
    | 
    |     /// @notice Integers in payoutSchedule must add up to 100
    |     /// @dev [0] is 1st place, [1] is 2nd, etc.
    |     uint256[] public payoutSchedule;
    |     mapping(address => uint256) public fundingTotals;
    |     mapping(uint256 => bool) public tierClaimed;
    | 
    |     // Tier associated with deposit
    |     mapping(bytes32 => uint256) public tier;
    | 
    |     bool[] public invoiceComplete;
    |     bool[] public supportingDocumentsComplete;
    |     string[] public tierWinners;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Storage/TieredFixedBountyStorage.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../Implementations/TieredBountyCore.sol';
    | 
    | /// @title TieredFixedBountyStorageV1
    | /// @author FlacoJones
    | /// @notice Backwards compatible, append-only chain of storage contracts inherited by all TieredFixedBountyStorage implementations
    | /// @dev Add new variables for upgrades in a new, derived abstract contract that inherits from the previous storage contract version (see: https://forum.openzeppelin.com/t/to-inherit-version1-to-version2-or-to-copy-code-inheritance-order-from-version1-to-version2/28069)
    | abstract contract TieredFixedBountyStorageV1 is TieredBountyCore {
    |     address public payoutTokenAddress;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Bounty/Storage/TieredPercentageBountyStorage.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../Implementations/TieredBountyCore.sol';
    | 
    | /// @title TieredPercentageBountyStorageV1
    | /// @author FlacoJones
    | /// @notice Backwards compatible, append-only chain of storage contracts inherited by all TieredPercentageBountyStorage implementations
    | /// @dev Add new variables for upgrades in a new, derived abstract contract that inherits from the previous storage contract version (see: https://forum.openzeppelin.com/t/to-inherit-version1-to-version2-or-to-copy-code-inheritance-order-from-version1-to-version2/28069)
    | abstract contract TieredPercentageBountyStorageV1 is TieredBountyCore {
    | 
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/BountyFactory/BountyFactory.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol';
    | 
    | import '../OnlyOpenQ/OnlyOpenQ.sol';
    | import '../Library/OpenQDefinitions.sol';
    | import '../Library/Errors.sol';
    | 
    | /// @title BountyFactory
    | /// @author FlacoJones
    | /// @notice Factory contract to deploy upgradeable beacon proxies for each type of bounty
    | contract BountyFactory is OnlyOpenQ {
    |     /// @notice The address of the UpgradeableBeacon holding the current bounty implementation
    |     address public immutable atomicBountyBeacon;
    |     address public immutable ongoingBountyBeacon;
    |     address public immutable tieredPercentageBountyBeacon;
    |     address public immutable tieredFixedBountyBeacon;
    | 
    |     /// @notice Deploys and initializes a new BeaconProxy with implementation pulled from the appropriate BountyBeacon
    |     /// @param _openQ The OpenQProxy address, used to initialize OnlyOpenQ
    |     /// @param _atomicBountyBeacon The UpgradeableBeacon "BountyBeacon" address for Atomic contracts
    |     /// @param _ongoingBountyBeacon The UpgradeableBeacon "BountyBeacon" address for Ongoing contracts
    |     /// @param _tieredPercentageBountyBeacon The UpgradeableBeacon "BountyBeacon" address for Tiered contracts
    |     /// @param _tieredFixedBountyBeacon The UpgradeableBeacon "BountyBeacon" address for Tiered Fixed contracts
    |     constructor(
    |         address _openQ,
    |         address _atomicBountyBeacon,
    |         address _ongoingBountyBeacon,
    |         address _tieredPercentageBountyBeacon,
    |         address _tieredFixedBountyBeacon
    |     ) {
    |         __OnlyOpenQ_init(_openQ);
    | 
    |         atomicBountyBeacon = _atomicBountyBeacon;
    |         ongoingBountyBeacon = _ongoingBountyBeacon;
    |         tieredPercentageBountyBeacon = _tieredPercentageBountyBeacon;
    |         tieredFixedBountyBeacon = _tieredFixedBountyBeacon;
    |     }
    | 
    |     /// @dev Deploys and initializes a new BeaconProxy with implementation pulled from BountyBeacon
    |     /// @param _id A UUID representing the bounty's off-chain source (e.g. a Github Issue Id)
    |     /// @param _issuer The address of the sender of the the mint transaction
    |     /// @param _organization A UUID representing the bounty's off-chain source (e.g. a Github Organization Id)
    |     /// @param _claimManager The address of the current ClaimManager. Will be used to initialize onlyClaimManager owned methods in the bounty
    |     /// @param _depositManager The address of the current DepositManager. Will be used to initialize onlyDepositManager owned methods in the bounty
    |     /// @param _operation ABI Encoded data to be decoded in the initializer of the bounty, with decode type dependent on bounty type
    |     /// @return address of the minted bounty
    |     function mintBounty(
    |         string memory _id,
    |         address _issuer,
    |         string memory _organization,
    |         address _claimManager,
    |         address _depositManager,
    |         OpenQDefinitions.InitOperation memory _operation
    |     ) external onlyOpenQ returns (address) {
    |         uint32 operationType = _operation.operationType;
    | 
    |         address beaconProxy;
    | 
    |         if (operationType == OpenQDefinitions.ATOMIC) {
    |             beaconProxy = atomicBountyBeacon;
    |         } else if (operationType == OpenQDefinitions.ONGOING) {
    |             beaconProxy = ongoingBountyBeacon;
    |         } else if (operationType == OpenQDefinitions.TIERED_PERCENTAGE) {
    |             beaconProxy = tieredPercentageBountyBeacon;
    |         } else if (operationType == OpenQDefinitions.TIERED_FIXED) {
    |             beaconProxy = tieredFixedBountyBeacon;
    |         } else {
    |             revert(Errors.UNKNOWN_BOUNTY_TYPE);
    |         }
    | 
    |         BeaconProxy bounty = new BeaconProxy(
    |             beaconProxy,
    |             abi.encodeWithSignature(
    |                 'initialize(string,address,string,address,address,address,(uint32,bytes))',
    |                 _id,
    |                 _issuer,
    |                 _organization,
    |                 openQ(),
    |                 _claimManager,
    |                 _depositManager,
    |                 _operation
    |             )
    |         );
    | 
    |         return address(bounty);
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/ClaimManager/ClaimManagerOwnable.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';
    | 
    | /// @title ClaimManagerOwnable
    | /// @author FlacoJones
    | /// @notice Restricts access for method calls to Oracle address
    | abstract contract ClaimManagerOwnable is ContextUpgradeable {
    |     /// INITIALIZATION
    | 
    |     /// @notice ClaimManagerProxy address
    |     address private _claimManager;
    | 
    |     /// @notice Initializes child contract with _initialClaimManager. Only callabel during initialization.
    |     /// @param _initialClaimManager The initial claim manager address
    |     function __ClaimManagerOwnable_init(address _initialClaimManager)
    |         internal
    |         onlyInitializing
    |     {
    |         _claimManager = _initialClaimManager;
    |     }
    | 
    |     /// @notice Returns the address of _claimManager
    |     function claimManager() external view virtual returns (address) {
    |         return _claimManager;
    |     }
    | 
    |     /// @notice Modifier to restrict access of methods to _claimManager address
    |     modifier onlyClaimManager() {
    |         require(
    |             _claimManager == _msgSender(),
    |             'ClaimManagerOwnable: caller is not the current OpenQ Claim Manager'
    |         );
    |         _;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/ClaimManager/Implementations/ClaimManagerV1.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../Storage/ClaimManagerStorage.sol';
    | import '../../Bounty/Interfaces/IAtomicBounty.sol';
    | import '../../Bounty/Interfaces/ITieredBounty.sol';
    | import '../../Bounty/Interfaces/IOngoingBounty.sol';
    | 
    | /// @title ClaimManagerV1
    | /// @author FlacoJones
    | /// @notice Sole contract authorized to attempt claims on all bounty types
    | /// @dev Emitter of all claim-related events
    | /// @dev Some claim methods are onlyOracle protected, others have exclusively on-chain claim criteria
    | contract ClaimManagerV1 is ClaimManagerStorageV1 {
    |     constructor() {}
    | 
    |     /// @notice Initializes the ClaimManager implementation with oracle address
    |     /// @param _oracle The address of the oracle authorized to call onlyOracle methods (e.g. claimBounty)
    |     /// @dev Can only be called once thanks to initializer (https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers)
    |     function initialize(address _oracle) external initializer onlyProxy {
    |         __Ownable_init();
    |         __UUPSUpgradeable_init();
    |         __Oraclize_init(_oracle);
    |     }
    | 
    |     /// @notice Calls appropriate claim method based on bounty type
    |     /// @param _bountyAddress The payout address of the bounty
    |     /// @param _closer The payout address of the claimant
    |     /// @param _closerData ABI Encoded data associated with this claim
    |     /// @dev see IAtomicBounty.close(_closerData) for _closerData ABI encoding schema
    |     function claimBounty(
    |         address _bountyAddress,
    |         address _closer,
    |         bytes calldata _closerData
    |     ) external onlyOracle onlyProxy {
    |         IBounty bounty = IBounty(payable(_bountyAddress));
    |         uint256 _bountyType = bounty.bountyType();
    | 
    |         if (_bountyType == OpenQDefinitions.ATOMIC) {
    |             // Decode to ensure data meets closerData schema before emitting any events
    |             abi.decode(_closerData, (address, string, address, string));
    | 
    |             _claimAtomicBounty(bounty, _closer, _closerData);
    |             bounty.close(_closer, _closerData);
    | 
    |             emit BountyClosed(
    |                 bounty.bountyId(),
    |                 _bountyAddress,
    |                 bounty.organization(),
    |                 _closer,
    |                 block.timestamp,
    |                 bounty.bountyType(),
    |                 _closerData,
    |                 VERSION_1
    |             );
    |         } else if (_bountyType == OpenQDefinitions.ONGOING) {
    |             _claimOngoingBounty(bounty, _closer, _closerData);
    |         } else if (_bountyType == OpenQDefinitions.TIERED_PERCENTAGE) {
    |             _claimTieredPercentageBounty(bounty, _closer, _closerData);
    |         } else if (_bountyType == OpenQDefinitions.TIERED_FIXED) {
    |             _claimTieredFixedBounty(bounty, _closer, _closerData);
    |         } else {
    |             revert(Errors.UNKNOWN_BOUNTY_TYPE);
    |         }
    | 
    |         emit ClaimSuccess(block.timestamp, _bountyType, _closerData, VERSION_1);
    |     }
    | 
    |     /// @notice Used for claimants who have:
    |     /// @notice A) Completed KYC with KYC DAO for their tier
    |     /// @notice B) Uploaded invoicing information for their tier
    |     /// @notice C) Uploaded any necessary financial forms for their tier
    |     /// @param _bountyAddress The payout address of the bounty
    |     /// @param _closerData ABI Encoded data associated with this claim
    |     function permissionedClaimTieredBounty(
    |         address _bountyAddress,
    |         bytes calldata _closerData
    |     ) external onlyProxy {
    |         IBounty bounty = IBounty(payable(_bountyAddress));
    | 
    |         (, , , , uint256 _tier) = abi.decode(
    |             _closerData,
    |             (address, string, address, string, uint256)
    |         );
    | 
    |         string memory closer = IOpenQ(openQ).addressToExternalUserId(
    |             msg.sender
    |         );
    | 
    |         require(
    |             keccak256(abi.encodePacked(closer)) !=
    |                 keccak256(abi.encodePacked('')),
    |             Errors.NO_ASSOCIATED_ADDRESS
    |         );
    | 
    |         require(
    |             keccak256(abi.encode(closer)) ==
    |                 keccak256(abi.encode(bounty.tierWinners(_tier))),
    |             Errors.CLAIMANT_NOT_TIER_WINNER
    |         );
    | 
    |         if (bounty.bountyType() == OpenQDefinitions.TIERED_FIXED) {
    |             _claimTieredFixedBounty(bounty, msg.sender, _closerData);
    |         } else if (bounty.bountyType() == OpenQDefinitions.TIERED_PERCENTAGE) {
    |             _claimTieredPercentageBounty(bounty, msg.sender, _closerData);
    |         } else {
    |             revert(Errors.NOT_A_COMPETITION_CONTRACT);
    |         }
    | 
    |         emit ClaimSuccess(
    |             block.timestamp,
    |             bounty.bountyType(),
    |             _closerData,
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Claim method for AtomicBounty
    |     /// @param _bounty The payout address of the bounty
    |     /// @param _closer The payout address of the claimant
    |     /// @param _closerData ABI Encoded data associated with this claim
    |     /// @dev See IAtomicBounty
    |     function _claimAtomicBounty(
    |         IAtomicBounty _bounty,
    |         address _closer,
    |         bytes calldata _closerData
    |     ) internal {
    |         _eligibleToClaimAtomicBounty(_bounty, _closer);
    | 
    |         for (uint256 i = 0; i < _bounty.getTokenAddresses().length; i++) {
    |             uint256 volume = _bounty.claimBalance(
    |                 _closer,
    |                 _bounty.getTokenAddresses()[i]
    |             );
    | 
    |             emit TokenBalanceClaimed(
    |                 _bounty.bountyId(),
    |                 address(_bounty),
    |                 _bounty.organization(),
    |                 _closer,
    |                 block.timestamp,
    |                 _bounty.getTokenAddresses()[i],
    |                 volume,
    |                 _bounty.bountyType(),
    |                 _closerData,
    |                 VERSION_1
    |             );
    |         }
    | 
    |         for (uint256 i = 0; i < _bounty.getNftDeposits().length; i++) {
    |             _bounty.claimNft(_closer, _bounty.nftDeposits(i));
    | 
    |             emit NFTClaimed(
    |                 _bounty.bountyId(),
    |                 address(_bounty),
    |                 _bounty.organization(),
    |                 _closer,
    |                 block.timestamp,
    |                 _bounty.tokenAddress(_bounty.nftDeposits(i)),
    |                 _bounty.tokenId(_bounty.nftDeposits(i)),
    |                 _bounty.bountyType(),
    |                 _closerData,
    |                 VERSION_1
    |             );
    |         }
    |     }
    | 
    |     /// @notice Claim method for OngoingBounty
    |     /// @param _bounty The payout address of the bounty
    |     /// @param _closer The payout address of the claimant
    |     /// @param _closerData ABI Encoded data associated with this claim
    |     /// @dev see IBountyCore.claimOngoingPayout.(_closerData) for _closerData ABI encoding schema
    |     function _claimOngoingBounty(
    |         IOngoingBounty _bounty,
    |         address _closer,
    |         bytes calldata _closerData
    |     ) internal {
    |         _eligibleToClaimOngoingBounty(_bounty, _closer, _closerData);
    | 
    |         (address tokenAddress, uint256 volume) = _bounty.claimOngoingPayout(
    |             _closer,
    |             _closerData
    |         );
    | 
    |         emit TokenBalanceClaimed(
    |             _bounty.bountyId(),
    |             address(_bounty),
    |             _bounty.organization(),
    |             _closer,
    |             block.timestamp,
    |             tokenAddress,
    |             volume,
    |             _bounty.bountyType(),
    |             _closerData,
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Claim method for TieredPercentageBounty
    |     /// @param _bounty The payout address of the bounty
    |     /// @param _closer The payout address of the claimant
    |     /// @param _closerData ABI Encoded data associated with this claim
    |     function _claimTieredPercentageBounty(
    |         IBounty _bounty,
    |         address _closer,
    |         bytes calldata _closerData
    |     ) internal {
    |         (, , , , uint256 _tier) = abi.decode(
    |             _closerData,
    |             (address, string, address, string, uint256)
    |         );
    | 
    |         _eligibleToClaimTier(_bounty, _tier, _closer);
    | 
    |         if (_bounty.status() == 0) {
    |             _bounty.closeCompetition();
    | 
    |             emit BountyClosed(
    |                 _bounty.bountyId(),
    |                 address(_bounty),
    |                 _bounty.organization(),
    |                 address(0),
    |                 block.timestamp,
    |                 _bounty.bountyType(),
    |                 new bytes(0),
    |                 VERSION_1
    |             );
    |         }
    | 
    |         for (uint256 i = 0; i < _bounty.getTokenAddresses().length; i++) {
    |             uint256 volume = _bounty.claimTiered(
    |                 _closer,
    |                 _tier,
    |                 _bounty.getTokenAddresses()[i]
    |             );
    | 
    |             emit TokenBalanceClaimed(
    |                 _bounty.bountyId(),
    |                 address(_bounty),
    |                 _bounty.organization(),
    |                 _closer,
    |                 block.timestamp,
    |                 _bounty.getTokenAddresses()[i],
    |                 volume,
    |                 _bounty.bountyType(),
    |                 _closerData,
    |                 VERSION_1
    |             );
    |         }
    | 
    |         for (uint256 i = 0; i < _bounty.getNftDeposits().length; i++) {
    |             bytes32 _depositId = _bounty.nftDeposits(i);
    |             if (_bounty.tier(_depositId) == _tier) {
    |                 _bounty.claimNft(_closer, _depositId);
    | 
    |                 emit NFTClaimed(
    |                     _bounty.bountyId(),
    |                     address(_bounty),
    |                     _bounty.organization(),
    |                     _closer,
    |                     block.timestamp,
    |                     _bounty.tokenAddress(_depositId),
    |                     _bounty.tokenId(_depositId),
    |                     _bounty.bountyType(),
    |                     _closerData,
    |                     VERSION_1
    |                 );
    |             }
    |         }
    | 
    |         _bounty.setTierClaimed(_tier);
    |     }
    | 
    |     /// @notice Claim method for TieredFixedBounty
    |     /// @param _bounty The payout address of the bounty
    |     /// @param _closer The payout address of the claimant
    |     /// @param _closerData ABI Encoded data associated with this claim
    |     function _claimTieredFixedBounty(
    |         IBounty _bounty,
    |         address _closer,
    |         bytes calldata _closerData
    |     ) internal {
    |         (, , , , uint256 _tier) = abi.decode(
    |             _closerData,
    |             (address, string, address, string, uint256)
    |         );
    | 
    |         _eligibleToClaimTier(_bounty, _tier, _closer);
    | 
    |         if (_bounty.status() == 0) {
    |             _bounty.closeCompetition();
    | 
    |             emit BountyClosed(
    |                 _bounty.bountyId(),
    |                 address(_bounty),
    |                 _bounty.organization(),
    |                 address(0),
    |                 block.timestamp,
    |                 _bounty.bountyType(),
    |                 new bytes(0),
    |                 VERSION_1
    |             );
    |         }
    | 
    |         uint256 volume = _bounty.claimTieredFixed(_closer, _tier);
    | 
    |         emit TokenBalanceClaimed(
    |             _bounty.bountyId(),
    |             address(_bounty),
    |             _bounty.organization(),
    |             _closer,
    |             block.timestamp,
    |             _bounty.payoutTokenAddress(),
    |             volume,
    |             _bounty.bountyType(),
    |             _closerData,
    |             VERSION_1
    |         );
    | 
    |         for (uint256 i = 0; i < _bounty.getNftDeposits().length; i++) {
    |             bytes32 _depositId = _bounty.nftDeposits(i);
    |             if (_bounty.tier(_depositId) == _tier) {
    |                 _bounty.claimNft(_closer, _depositId);
    | 
    |                 emit NFTClaimed(
    |                     _bounty.bountyId(),
    |                     address(_bounty),
    |                     _bounty.organization(),
    |                     _closer,
    |                     block.timestamp,
    |                     _bounty.tokenAddress(_depositId),
    |                     _bounty.tokenId(_depositId),
    |                     _bounty.bountyType(),
    |                     _closerData,
    |                     VERSION_1
    |                 );
    |             }
    |         }
    | 
    |         _bounty.setTierClaimed(_tier);
    |     }
    | 
    |     /// @notice Checks if bounty associated with _bountyId is open
    |     /// @return bool True if _bountyId is associated with an open bounty
    |     function bountyIsClaimable(address _bountyAddress)
    |         public
    |         view
    |         returns (bool)
    |     {
    |         IBounty bounty = IBounty(payable(_bountyAddress));
    | 
    |         uint256 status = bounty.status();
    |         uint256 _bountyType = bounty.bountyType();
    | 
    |         if (
    |             _bountyType == OpenQDefinitions.ATOMIC ||
    |             _bountyType == OpenQDefinitions.ONGOING ||
    |             _bountyType == OpenQDefinitions.TIERED_PERCENTAGE ||
    |             _bountyType == OpenQDefinitions.TIERED_FIXED
    |         ) {
    |             return status == 0;
    |         } else {
    |             return status == 1;
    |         }
    |     }
    | 
    |     /// @notice Override for UUPSUpgradeable._authorizeUpgrade(address newImplementation) to enforce onlyOwner upgrades
    |     function _authorizeUpgrade(address) internal override onlyOwner {}
    | 
    |     /// @notice Exposes internal method Oraclize._transferOracle(address) restricted to onlyOwner called via proxy
    |     /// @param _newOracle The new oracle address
    |     function transferOracle(address _newOracle) external onlyProxy onlyOwner {
    |         require(_newOracle != address(0), Errors.NO_ZERO_ADDRESS);
    |         _transferOracle(_newOracle);
    |     }
    | 
    |     /// @notice Sets the OpenQProxy address used for checking IOpenQ(openQ).addressToExternalUserId
    |     function setOpenQ(address _openQ) external onlyProxy onlyOwner {
    |         openQ = _openQ;
    |     }
    | 
    |     /// @notice Sets the KYC DAO contract address
    |     /// @param _kyc The KYC DAO contract address
    |     function setKyc(address _kyc) external onlyProxy onlyOwner {
    |         kyc = IKycValidity(_kyc);
    |     }
    | 
    |     /// @notice Checks the current KYC DAO contract address (kyc)to see if user has a valid KYC NFT or not
    |     /// @return True if address is KYC with KYC DAO, false otherwise
    |     function hasKYC(address _address) public view returns (bool) {
    |         return kyc.hasValidToken(_address);
    |     }
    | 
    |     /// @notice Runs all require statements to determine if the claimant can claim the specified tier on the tiered bounty
    |     function _eligibleToClaimTier(
    |         ITieredBounty _bounty,
    |         uint256 _tier,
    |         address _closer
    |     ) internal view {
    |         require(!_bounty.tierClaimed(_tier), Errors.TIER_ALREADY_CLAIMED);
    | 
    |         if (_bounty.invoiceRequired()) {
    |             require(
    |                 _bounty.invoiceComplete(_tier),
    |                 Errors.INVOICE_NOT_COMPLETE
    |             );
    |         }
    | 
    |         if (_bounty.supportingDocumentsRequired()) {
    |             require(
    |                 _bounty.supportingDocumentsComplete(_tier),
    |                 Errors.SUPPORTING_DOCS_NOT_COMPLETE
    |             );
    |         }
    | 
    |         if (_bounty.kycRequired()) {
    |             require(hasKYC(_closer), Errors.ADDRESS_LACKS_KYC);
    |         }
    |     }
    | 
    |     /// @notice Runs all require statements to determine if the claimant can claim the atomic bounty
    |     function _eligibleToClaimAtomicBounty(IAtomicBounty bounty, address _closer)
    |         internal
    |         view
    |     {
    |         require(
    |             bounty.status() == OpenQDefinitions.OPEN,
    |             Errors.CONTRACT_IS_NOT_CLAIMABLE
    |         );
    | 
    |         if (bounty.invoiceRequired()) {
    |             bool _invoiceComplete = abi.decode(
    |                 bounty.getInvoiceComplete(),
    |                 (bool)
    |             );
    |             require(_invoiceComplete, Errors.INVOICE_NOT_COMPLETE);
    |         }
    | 
    |         if (bounty.supportingDocumentsRequired()) {
    |             bool _supportingDocumentsComplete = abi.decode(
    |                 bounty.getSupportingDocumentsComplete(),
    |                 (bool)
    |             );
    |             require(
    |                 _supportingDocumentsComplete,
    |                 Errors.SUPPORTING_DOCS_NOT_COMPLETE
    |             );
    |         }
    | 
    |         if (bounty.kycRequired()) {
    |             require(hasKYC(_closer), Errors.ADDRESS_LACKS_KYC);
    |         }
    |     }
    | 
    |     /// @notice Runs all require statements to determine if the claimant can claim an ongoing bounty payout
    |     function _eligibleToClaimOngoingBounty(
    |         IOngoingBounty bounty,
    |         address _closer,
    |         bytes memory _closerData
    |     ) internal view {
    |         require(
    |             bounty.status() == OpenQDefinitions.OPEN,
    |             Errors.CONTRACT_IS_NOT_CLAIMABLE
    |         );
    | 
    |         (, string memory claimant, , string memory claimantAsset) = abi.decode(
    |             _closerData,
    |             (address, string, address, string)
    |         );
    | 
    |         bytes32 claimId = bounty.generateClaimId(claimant, claimantAsset);
    | 
    |         if (bounty.invoiceRequired()) {
    |             require(
    |                 bounty.invoiceComplete(claimId),
    |                 Errors.INVOICE_NOT_COMPLETE
    |             );
    |         }
    | 
    |         if (bounty.supportingDocumentsRequired()) {
    |             require(
    |                 bounty.supportingDocumentsComplete(claimId),
    |                 Errors.SUPPORTING_DOCS_NOT_COMPLETE
    |             );
    |         }
    | 
    |         if (bounty.kycRequired()) {
    |             require(hasKYC(_closer), Errors.ADDRESS_LACKS_KYC);
    |         }
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/ClaimManager/Interfaces/IClaimManager.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | /// @title IClaimManager
    | /// @author FlacoJones
    | /// @notice Interface for ClaimManager defining all events
    | interface IClaimManager {
    |     /// @notice Emitted when any bounty type is closed
    |     /// @param bountyId Unique bounty id
    |     /// @param bountyAddress Address of the bounty associated with the event
    |     /// @param organization Address of the bounty associated with the event
    |     /// @param closer Address of the recipient of the funds
    |     /// @param bountyClosedTime Block timestamp of the close
    |     /// @param bountyType The type of bounty closed. See OpenQDefinitions.sol
    |     /// @param data ABI encoded data associated with the BountyClosed event. Specific to each bounty type.
    |     /// @param version Which version of ClaimManager emitted the event. Increments with each ClaimManager release to instruct data decoding
    |     event BountyClosed(
    |         string bountyId,
    |         address bountyAddress,
    |         string organization,
    |         address closer,
    |         uint256 bountyClosedTime,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     /// @notice Emitted when a claim occurs on any bounty type
    |     /// @param claimTime The block timestamp in which the claim occurred
    |     /// @param bountyType The type of bounty closed. See OpenQDefinitions.sol
    |     /// @param data ABI encoded data associated with the ClaimSuccess event. Specific to each bounty type.
    |     /// @param version Which version of ClaimManager emitted the event. Increments with each ClaimManager release to instruct data decoding
    |     event ClaimSuccess(
    |         uint256 claimTime,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     /// @notice Emitted any time a volume of tokens is claimed
    |     /// @param bountyId Unique bounty id
    |     /// @param bountyAddress Address of the bounty associated with the event
    |     /// @param organization Address of the bounty associated with the event
    |     /// @param closer Address of the recipient of the funds
    |     /// @param payoutTime Block timestamp of the claim
    |     /// @param tokenAddress Address of the token
    |     /// @param volume Volume of the token claim
    |     /// @param bountyType The type of bounty closed. See OpenQDefinitions.sol
    |     /// @param data ABI encoded data associated with the TokenBalanceClaimed event. Specific to each bounty type.
    |     /// @param version Which version of ClaimManager emitted the event. Increments with each ClaimManager release to instruct data decoding
    |     event TokenBalanceClaimed(
    |         string bountyId,
    |         address bountyAddress,
    |         string organization,
    |         address closer,
    |         uint256 payoutTime,
    |         address tokenAddress,
    |         uint256 volume,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     /// @notice
    |     /// @param bountyId Unique bounty id
    |     /// @param bountyAddress Address of the bounty associated with the event
    |     /// @param organization Address of the bounty associated with the event
    |     /// @param closer Address of the recipient of the funds
    |     /// @param payoutTime Block timestamp of the claim
    |     /// @param tokenAddress Address of the token
    |     /// @param tokenId Token ID of the NFT claimed
    |     /// @param bountyType The type of bounty closed. See OpenQDefinitions.sol
    |     /// @param data ABI encoded data associated with the NFTClaimed event. Specific to each bounty type.
    |     /// @param version Which version of ClaimManager emitted the event. Increments with each ClaimManager release to instruct data decoding
    |     event NFTClaimed(
    |         string bountyId,
    |         address bountyAddress,
    |         string organization,
    |         address closer,
    |         uint256 payoutTime,
    |         address tokenAddress,
    |         uint256 tokenId,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/ClaimManager/Storage/ClaimManagerStorage.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
    | import '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';
    | 
    | import '../Interfaces/IClaimManager.sol';
    | import '../../OpenQ/Interfaces/IOpenQ.sol';
    | import '../../Library/OpenQDefinitions.sol';
    | import '../../Oracle/Oraclize.sol';
    | import '../../Bounty/Interfaces/IBounty.sol';
    | import '../../Library/Errors.sol';
    | import '../../KYC/IKycValidity.sol';
    | 
    | /// @title ClaimManagerStorageV1
    | /// @author FlacoJones
    | /// @notice Backwards compatible, append-only chain of storage contracts inherited by all ClaimManager implementations
    | /// @dev Add new variables for upgrades in a new, derived abstract contract that inherits from the previous storage contract version (see: https://forum.openzeppelin.com/t/to-inherit-version1-to-version2-or-to-copy-code-inheritance-order-from-version1-to-version2/28069)
    | abstract contract ClaimManagerStorageV1 is
    |     IClaimManager,
    |     Oraclize,
    |     OwnableUpgradeable,
    |     UUPSUpgradeable
    | {
    |     uint256 public constant VERSION_1 = 1;
    |     address public openQ;
    |     IKycValidity public kyc;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/DepositManager/DepositManagerOwnable.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';
    | 
    | /// @title DepositManagerOwnable
    | /// @notice Restricts access for method calls to Deposit Manager address
    | abstract contract DepositManagerOwnable is ContextUpgradeable {
    |     /// @notice Deposit Manager address
    |     address private _depositManager;
    | 
    |     /// @notice Initializes child contract with _initialDepositManager. Only callabel during initialization.
    |     /// @param _initialDepositManager The initial oracle address
    |     function __DepositManagerOwnable_init(address _initialDepositManager)
    |         internal
    |         onlyInitializing
    |     {
    |         _depositManager = _initialDepositManager;
    |     }
    | 
    |     /// @notice Returns the address of _depositManager
    |     function depositManager() external view virtual returns (address) {
    |         return _depositManager;
    |     }
    | 
    |     /// @notice Modifier to restrict access of methods to _depositManager address
    |     modifier onlyDepositManager() {
    |         require(
    |             _depositManager == _msgSender(),
    |             'DepositManagerOwnable: caller is not the current OpenQ Deposit Manager'
    |         );
    |         _;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/DepositManager/Implementations/DepositManagerV1.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../Storage/DepositManagerStorage.sol';
    | 
    | /// @title DepositManagerV1
    | /// @author FlacoJones
    | /// @notice Manager contract for depositing protocol, ERC-20, and ERC-721 on bounty contracts
*   | /// @notice Emitter of all deposit-related events
    | contract DepositManagerV1 is DepositManagerStorageV1 {
    |     constructor() {}
    | 
    |     /// @notice Initializes the DepositManager implementation
    |     /// @notice Can only be called once thanks to initializer (https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers)
    |     function initialize() external initializer {
    |         __Ownable_init();
    |         __UUPSUpgradeable_init();
    |     }
    | 
    |     /// @notice Sets openQTokenWhitelist address
    |     /// @param _openQTokenWhitelist The OpenQTokenWhitelist address
    |     function setTokenWhitelist(address _openQTokenWhitelist)
    |         external
    |         onlyOwner
    |         onlyProxy
    |     {
    |         openQTokenWhitelist = OpenQTokenWhitelist(_openQTokenWhitelist);
    |     }
    | 
    |     /// @notice Transfers protocol token or ERC20 from msg.sender to bounty address
    |     /// @param _bountyAddress A bounty address
    |     /// @param _tokenAddress The ERC20 token address (ZeroAddress if funding with protocol token)
    |     /// @param _volume The volume of token transferred
    |     /// @param _expiration The duration until the deposit becomes refundable
    |     /// @param funderUuid The external user id of the funder
    |     function fundBountyToken(
    |         address _bountyAddress,
    |         address _tokenAddress,
    |         uint256 _volume,
    |         uint256 _expiration,
    |         string memory funderUuid
    |     ) external payable onlyProxy {
    |         IBounty bounty = IBounty(payable(_bountyAddress));
    | 
    |         if (!isWhitelisted(_tokenAddress)) {
    |             require(
    |                 !tokenAddressLimitReached(_bountyAddress),
    |                 Errors.TOO_MANY_TOKEN_ADDRESSES
    |             );
    |         }
    | 
    |         require(bountyIsOpen(_bountyAddress), Errors.CONTRACT_ALREADY_CLOSED);
    | 
    |         (bytes32 depositId, uint256 volumeReceived) = bounty.receiveFunds{
    |             value: msg.value
    |         }(msg.sender, _tokenAddress, _volume, _expiration);
    | 
    |         bytes memory funderUuidBytes = abi.encode(funderUuid);
    | 
    |         emit TokenDepositReceived(
    |             depositId,
    |             _bountyAddress,
    |             bounty.bountyId(),
    |             bounty.organization(),
    |             _tokenAddress,
    |             block.timestamp,
    |             msg.sender,
    |             _expiration,
    |             volumeReceived,
    |             0,
    |             funderUuidBytes,
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Extends the expiration for a deposit
    |     /// @param _bountyAddress Bounty address
    |     /// @param _depositId The deposit to extend
    |     /// @param _seconds The duration to add until the deposit becomes refundable
    |     function extendDeposit(
    |         address _bountyAddress,
    |         bytes32 _depositId,
    |         uint256 _seconds
    |     ) external onlyProxy {
    |         IBounty bounty = IBounty(payable(_bountyAddress));
    | 
    |         require(
    |             bounty.funder(_depositId) == msg.sender,
    |             Errors.CALLER_NOT_FUNDER
    |         );
    | 
    |         uint256 newExpiration = bounty.extendDeposit(
    |             _depositId,
    |             _seconds,
    |             msg.sender
    |         );
    | 
    |         emit DepositExtended(
    |             _depositId,
    |             newExpiration,
    |             0,
    |             new bytes(0),
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Transfers NFT from msg.sender to bounty address
    |     /// @param _bountyAddress The address of the bounty to fund
    |     /// @param _tokenAddress The ERC721 token address of the NFT
    |     /// @param _tokenId The tokenId of the NFT to transfer
    |     /// @param _expiration The duration until the deposit becomes refundable
    |     /// @param _data The tier of the NFT (not relevant for non-tiered bounties)
    |     function fundBountyNFT(
    |         address _bountyAddress,
    |         address _tokenAddress,
    |         uint256 _tokenId,
    |         uint256 _expiration,
    |         bytes calldata _data
    |     ) external onlyProxy {
    |         IBounty bounty = IBounty(payable(_bountyAddress));
    | 
    |         require(isWhitelisted(_tokenAddress), Errors.TOKEN_NOT_ACCEPTED);
    |         require(bountyIsOpen(_bountyAddress), Errors.CONTRACT_ALREADY_CLOSED);
    | 
    |         bytes32 depositId = bounty.receiveNft(
    |             msg.sender,
    |             _tokenAddress,
    |             _tokenId,
    |             _expiration,
    |             _data
    |         );
    | 
    |         emit NFTDepositReceived(
    |             depositId,
    |             _bountyAddress,
    |             bounty.bountyId(),
    |             bounty.organization(),
    |             _tokenAddress,
    |             block.timestamp,
    |             msg.sender,
    |             _expiration,
    |             _tokenId,
    |             0,
    |             _data,
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Refunds an individual deposit from bountyAddress to sender if expiration time has passed
    |     /// @param _bountyAddress The address of the bounty that has the deposit to refund
    |     /// @param _depositId The depositId associated with the deposit being refunded
    |     function refundDeposit(address _bountyAddress, bytes32 _depositId)
    |         external
    |         onlyProxy
    |     {
    |         IBounty bounty = IBounty(payable(_bountyAddress));
    | 
    |         require(
    |             bounty.funder(_depositId) == msg.sender,
    |             Errors.CALLER_NOT_FUNDER
    |         );
    | 
    |         require(
    |             block.timestamp >=
    |                 bounty.depositTime(_depositId) + bounty.expiration(_depositId),
    |             Errors.PREMATURE_REFUND_REQUEST
    |         );
    | 
    |         address depToken = bounty.tokenAddress(_depositId);
    | 
    |         uint256 availableFunds = bounty.getTokenBalance(depToken) -
    |             bounty.getLockedFunds(depToken);
    | 
    |         uint256 volume;
    |         if (bounty.volume(_depositId) <= availableFunds) {
    |             volume = bounty.volume(_depositId);
    |         } else {
    |             volume = availableFunds;
    |         }
    | 
    |         bounty.refundDeposit(_depositId, msg.sender, volume);
    | 
    |         emit DepositRefunded(
    |             _depositId,
    |             bounty.bountyId(),
    |             _bountyAddress,
    |             bounty.organization(),
    |             block.timestamp,
    |             bounty.tokenAddress(_depositId),
    |             volume,
    |             0,
    |             new bytes(0),
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Checks if _tokenAddress is whitelisted
    |     /// @param _tokenAddress The token address in question
    |     /// @return True if _tokenAddress is whitelisted, false otherwise
    |     function isWhitelisted(address _tokenAddress) public view returns (bool) {
    |         return openQTokenWhitelist.isWhitelisted(_tokenAddress);
    |     }
    | 
    |     /// @notice Returns true if the total number of unique tokens deposited on then bounty is greater than the OpenQWhitelist TOKEN_ADDRESS_LIMIT
    |     /// @param _bountyAddress Address of bounty
    |     /// @return True if the token address limit has been reached
    |     function tokenAddressLimitReached(address _bountyAddress)
    |         public
    |         view
    |         returns (bool)
    |     {
    |         IBounty bounty = IBounty(payable(_bountyAddress));
    | 
    |         return
    |             bounty.getTokenAddressesCount() >=
    |             openQTokenWhitelist.TOKEN_ADDRESS_LIMIT();
    |     }
    | 
    |     /// @notice Checks if bounty associated with _bountyId is open
    |     /// @param _bountyAddress Address of bounty
    |     /// @return bool True if _bountyId is associated with an open bounty
    |     function bountyIsOpen(address _bountyAddress) public view returns (bool) {
    |         IBounty bounty = IBounty(payable(_bountyAddress));
    |         bool isOpen = bounty.status() == OpenQDefinitions.OPEN;
    |         return isOpen;
    |     }
    | 
    |     /// @notice Override for UUPSUpgradeable._authorizeUpgrade(address newImplementation) to enforce onlyOwner upgrades
    |     function _authorizeUpgrade(address) internal override onlyOwner {}
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/DepositManager/Interfaces/IDepositManager.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | interface IDepositManager {
    |     event TokenDepositReceived(
    |         bytes32 depositId,
    |         address bountyAddress,
    |         string bountyId,
    |         string organization,
    |         address tokenAddress,
    |         uint256 receiveTime,
    |         address sender,
    |         uint256 expiration,
    |         uint256 volume,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event NFTDepositReceived(
    |         bytes32 depositId,
    |         address bountyAddress,
    |         string bountyId,
    |         string organization,
    |         address tokenAddress,
    |         uint256 receiveTime,
    |         address sender,
    |         uint256 expiration,
    |         uint256 tokenId,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event DepositRefunded(
    |         bytes32 depositId,
    |         string bountyId,
    |         address bountyAddress,
    |         string organization,
    |         uint256 refundTime,
    |         address tokenAddress,
    |         uint256 volume,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event DepositExtended(
    |         bytes32 depositId,
    |         uint256 newExpiration,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/DepositManager/Storage/DepositManagerStorage.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
    | import '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';
    | 
    | import '..//Interfaces/IDepositManager.sol';
    | import '../../TokenWhitelist/OpenQTokenWhitelist.sol';
    | import '../../Bounty/Interfaces/IBounty.sol';
    | import '../../Library/Errors.sol';
    | 
    | /// @title DepositManagerStorageV1
    | /// @author FlacoJones
    | /// @notice Backwards compatible, append-only chain of storage contracts inherited by all DepositManager implementations
    | /// @dev Add new variables for upgrades in a new, derived abstract contract that inherits from the previous storage contract version (see: https://forum.openzeppelin.com/t/to-inherit-version1-to-version2-or-to-copy-code-inheritance-order-from-version1-to-version2/28069)
    | abstract contract DepositManagerStorageV1 is
    |     IDepositManager,
    |     OwnableUpgradeable,
    |     UUPSUpgradeable
    | {
*   |     uint256 public constant VERSION_1 = 1;
    |     OpenQTokenWhitelist public openQTokenWhitelist;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Fuzz/BountyFuzzTest.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import './FunctionWrappers.sol';
    | 
    | contract BountyFuzzTest is FunctionWrappers {
    |     constructor() {}
    | 
    |     /// @notice Checks that no codepath exists that can change the issuer of a bounty
    |     function assert_bounty_issuer_never_changes() public {
    |         //************************* Pre-Conditions *************************/
    |         if (!bountiesDeployed) deployBounties();
    | 
    |         //************************* Action *************************/
    | 
    |         //************************* Post-Conditions *************************/
    |         assert(atomicBounty.issuer() == address(minter));
    |         assert(ongoingBounty.issuer() == address(minter));
    |         assert(tieredFixedBounty.issuer() == address(minter));
    |         assert(tieredPercentageBounty.issuer() == address(minter));
    |     }
    | 
    |     // fundBountyToken always leads to higher balance
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Fuzz/ClaimManagerV1FuzzTest.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import './FunctionWrappers.sol';
*r  | 
    | contract ClaimManagerV1FuzzTest is FunctionWrappers {
    |     constructor() {
    |         // claimManager.renounceOwnership();
    |     }
    | 
    |     /// @notice Checks that no codepath exists that can change oracle BESIDES transferOracle()
    |     /// @dev Renounce ownership, and oracle should never be able to be transferred again
*   |     function assert_cannot_transfer_oracle() public view {
*   |         assert(address(claimManager.oracle()) == address(oracle));
    |     }
    | 
    |     /// @notice Checks that no codepath exists that can call initialize after initialization
    |     /// @dev Initialize is called in constructor of Setup.sol
*r  |     function assert_cannot_call_initialize() public {
*   |         (bool success, ) = payable(address(claimManager)).call(
*   |             abi.encodeWithSignature('initialize()')
    |         );
*r  |         assert(!success);
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Fuzz/DepositManagerV1FuzzTest.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import './FunctionWrappers.sol';
    | 
    | contract DepositManagerV1FuzzTest is FunctionWrappers {
    |     constructor() {
    |         depositManager.renounceOwnership();
    |     }
    | 
    |     /// @notice Checks that no codepath exists that can change oracle BESIDES transferOracle()
    |     /// @dev Renounce ownership, and oracle should never be able to be transferred again
    |     function assert_cannot_set_token_whitelist() public view {
    |         assert(
    |             address(depositManager.openQTokenWhitelist()) == openQTokenWhiteList
    |         );
    |     }
    | 
    |     /// @notice Checks that no codepath exists that can call initialize after initialization
    |     /// @dev Initialize is called in constructor of Setup.sol
    |     function assert_cannot_call_initialize() public {
    |         (bool success, ) = payable(address(depositManager)).call(
    |             abi.encodeWithSignature('initialize()')
    |         );
    |         assert(!success);
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Fuzz/FunctionWrappers.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import './Setup.sol';
    | 
    | /// @title FunctionWrappers
    | /// @author FlacoJones
    | /// @notice Wraps methods across contracts so they can be fuzzed
    | /// @dev Echidna only fuzzes and calls methods which are public and external in the inheritance chain of your Echidna fuzz-test contracts
    | contract FunctionWrappers is Setup {
    |     constructor() {}
    | 
    |     //************************* OPENQ *************************/
*r  |     function _transferOracle(address _newOracle) public {
*r  |         require(_newOracle != address(0), 'No zero address');
*r  |         openQ.transferOracle(_newOracle);
    |     }
    | 
*   |     function _setBountyFactory(address _newBountyFactory) public {
*   |         require(_newBountyFactory != address(0), 'No zero address');
*   |         openQ.setBountyFactory(_newBountyFactory);
    |     }
    | 
*r  |     function _setClaimManager(address _newClaimManager) public {
*r  |         require(_newClaimManager != address(0), 'No zero address');
*r  |         openQ.setClaimManager(_newClaimManager);
    |     }
    | 
*   |     function _setDepositManager(address _newDepositManager) public {
*   |         require(_newDepositManager != address(0), 'No zero address');
*   |         openQ.setDepositManager(_newDepositManager);
    |     }
    | 
*r  |     function _upgradeToOpenQ(address _newImplementation) public {
*r  |         require(_newImplementation != address(0), 'No zero address');
*r  |         openQ.upgradeTo(_newImplementation);
    |     }
    | 
    |     //************************* DEPOSIT MANAGER *************************/
*r  |     function _setTokenWhitelist(address _newTokenWhitelist) public {
*r  |         require(_newTokenWhitelist != address(0), 'No zero address');
*r  |         depositManager.setTokenWhitelist(_newTokenWhitelist);
    |     }
    | 
*r  |     function _upgradeToDepositManager(address _newImplementation) public {
*r  |         require(_newImplementation != address(0), 'No zero address');
*r  |         depositManager.upgradeTo(_newImplementation);
    |     }
    | 
    |     //************************* CLAIM MANAGER *************************/
r   |     function _upgradeToClaimManager(address _newImplementation) public {
r   |         require(_newImplementation != address(0), 'No zero address');
r   |         claimManager.upgradeTo(_newImplementation);
    |     }
    | 
*   |     function _setOpenQ(address _newOpenQ) public {
*   |         require(_newOpenQ != address(0), 'No zero address');
*   |         claimManager.setOpenQ(_newOpenQ);
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Fuzz/OpenQV1FuzzTest.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import './FunctionWrappers.sol';
    | 
    | contract OpenQV1FuzzTest is FunctionWrappers {
    |     constructor() {
    |         openQ.renounceOwnership();
    |     }
    | 
    |     /// @notice Checks that no codepath exists that can change oracle BESIDES transferOracle()
    |     /// @dev Renounce ownership, and oracle should never be able to be transferred again
    |     function assert_cannot_transfer_oracle() public view {
    |         assert(openQ.oracle() == address(oracle));
    |     }
    | 
    |     /// @notice Checks that no codepath exists that can change oracle BESIDES owner calling setBountyFactory()
    |     /// @dev Renounce ownership in constructor, and setBountyFactory should become inaccessible
    |     function assert_cannot_set_bounty_factory() public view {
    |         assert(address(openQ.bountyFactory()) == address(bountyFactory));
    |     }
    | 
    |     /// @notice Checks that no codepath exists that can change oracle BESIDES owner calling setClaimManager()
    |     /// @dev Renounce ownership in constructor, and setClaimManager should become inaccessible
    |     function assert_cannot_set_claim_manager() public view {
    |         assert(openQ.claimManager() == address(claimManager));
    |     }
    | 
    |     /// @notice Checks that no codepath exists that can change oracle BESIDES owner calling setDepositManager()
    |     /// @dev Renounce ownership in constructor, and setDepositManager should become inaccessible
    |     function assert_cannot_set_deposit_manager() public view {
    |         assert(openQ.depositManager() == address(depositManager));
    |     }
    | 
    |     /// @notice Checks that no codepath exists that can call initialize after initialization
    |     /// @dev Initialize is called in constructor of Setup.sol
    |     function assert_cannot_call_initialize() public {
    |         (bool success, ) = payable(address(openQ)).call(
    |             abi.encodeWithSignature('initialize()')
    |         );
    |         assert(!success);
    |     }
    | 
    |     /// @notice Checks that no codepath exists that can upgrade implementation BESIDES owner calling upgradeTo()
    |     /// @dev Renounce ownership in constructor, and upgradeTo should become inaccessible
    |     function assert_cannot_call_upgrade_to() public view {
    |         assert(openQ.getImplementation() == openQImplementation);
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Fuzz/Setup.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../OpenQ/Implementations/OpenQV1.sol';
    | import '../OpenQ/Proxy/OpenQProxy.sol';
    | import '../BountyFactory/BountyFactory.sol';
    | import '../Library/OpenQDefinitions.sol';
    | import '../Bounty/Proxy/BountyBeacon.sol';
    | import '../Bounty/Implementations/AtomicBountyV1.sol';
    | import '../Bounty/Implementations/OngoingBountyV1.sol';
    | import '../Bounty/Implementations/TieredPercentageBountyV1.sol';
    | import '../Bounty/Implementations/TieredFixedBountyV1.sol';
    | import '../ClaimManager/Implementations/ClaimManagerV1.sol';
    | import '../DepositManager/Implementations/DepositManagerV1.sol';
    | import '../TokenWhitelist/OpenQTokenWhitelist.sol';
    | import './Users.sol';
    | 
    | contract Setup {
    |     event DebugBytes(bytes _bytes);
    |     event DebugAddress(address _address);
    |     event DebugUint256(uint256 _uint256);
    | 
    |     OpenQV1 openQ;
    |     ClaimManagerV1 claimManager;
    |     DepositManagerV1 depositManager;
    |     BountyFactory bountyFactory;
    |     address openQImplementation;
    |     address openQTokenWhiteList;
    | 
    |     AtomicBountyV1 atomicBounty;
    |     OngoingBountyV1 ongoingBounty;
    |     TieredPercentageBountyV1 tieredPercentageBounty;
    |     TieredFixedBountyV1 tieredFixedBounty;
    | 
    |     string atomicBountyId = 'atomicBountyId';
    |     string ongoingBountyId = 'ongoingBountyId';
    |     string tieredBountyId = 'tieredBountyId';
    |     string tieredFixedBountyId = 'tieredFixedBountyId';
    | 
    |     // Simulated EOAs
    |     Users owner;
    |     Users oracle;
    |     Users minter;
    | 
    |     bool bountiesDeployed;
    | 
    |     constructor() {
    |         // CREATE USER PROXIES (SIMULATES AND EOA)
    |         owner = new Users();
    |         oracle = new Users();
    |         minter = new Users();
    | 
    |         // DEPLOY BOUNTY IMPLEMENTATIONS
    |         address atomicBountyV1 = address(new AtomicBountyV1());
    |         address ongoingBountyV1 = address(new OngoingBountyV1());
    |         address tieredPercentageBountyV1 = address(
    |             new TieredPercentageBountyV1()
    |         );
    |         address tieredFixedBountyV1 = address(new TieredFixedBountyV1());
    | 
    |         // DEPLOY BOUNTY BEACONS
    |         address atomicBountyBeacon = address(new BountyBeacon(atomicBountyV1));
    |         address ongoingBountyBeacon = address(
    |             new BountyBeacon(ongoingBountyV1)
    |         );
    |         address tieredPercentageBountyBeacon = address(
    |             new BountyBeacon(tieredPercentageBountyV1)
    |         );
    |         address tieredFixedBountyBeacon = address(
    |             new BountyBeacon(tieredFixedBountyV1)
    |         );
    | 
    |         // DEPLOY AND INITIALIZE OPENQ IMPLEMENTATION AND PROXY
    |         openQImplementation = address(new OpenQV1());
    | 
    |         address openQProxy = address(
    |             new OpenQProxy(openQImplementation, new bytes(0))
    |         );
    | 
    |         openQ = OpenQV1(openQProxy);
    |         openQ.initialize();
    | 
    |         // DEPLOY BOUNTY FACTORY
    |         bountyFactory = new BountyFactory(
    |             address(openQ),
    |             atomicBountyBeacon,
    |             ongoingBountyBeacon,
    |             tieredPercentageBountyBeacon,
    |             tieredFixedBountyBeacon
    |         );
    | 
    |         // DEPLOY AND INITIALIZE CLAIM MANAGER
    |         address claimManagerImplementation = address(new ClaimManagerV1());
    | 
    |         address claimManagerProxy = address(
    |             new OpenQProxy(claimManagerImplementation, new bytes(0))
    |         );
    | 
    |         claimManager = ClaimManagerV1(claimManagerProxy);
    |         claimManager.initialize(address(oracle));
    | 
    |         // DEPLOY AND INITIALIZE DEPOSIT MANAGER
    |         address depositManagerImplementation = address(new DepositManagerV1());
    | 
    |         address depositManagerProxy = address(
    |             new OpenQProxy(depositManagerImplementation, new bytes(0))
    |         );
    | 
    |         depositManager = DepositManagerV1(depositManagerProxy);
    |         depositManager.initialize();
    | 
    |         // DEPLOY OPENQTOKENWHITELIST
    |         openQTokenWhiteList = address(new OpenQTokenWhitelist(5));
    | 
    |         openQ.setBountyFactory(address(bountyFactory));
    |         openQ.setClaimManager(address(claimManager));
    |         openQ.setDepositManager(address(depositManager));
    |         openQ.transferOracle(address(oracle));
    | 
    |         depositManager.setTokenWhitelist(openQTokenWhiteList);
    | 
    |         claimManager.setKyc(address(0));
    |     }
    | 
    |     // make a private setUp method and call if not completed, so this won't be called by fuzzr
    |     function deployBounties() internal {
    |         //************************* Mint Atomic Bounty *************************/
    |         bytes memory initDataAtomic = abi.encode(
    |             true,
    |             address(0),
    |             100,
    |             true,
    |             true,
    |             true,
    |             '_issuerExternalUserId',
    |             'alternativeName',
    |             'alternativeLogo'
    |         );
    | 
    |         (bool successAtomic, bytes memory resultAtomic) = minter.proxy(
    |             address(openQ),
    |             abi.encodeWithSelector(
    |                 openQ.mintBounty.selector,
    |                 atomicBountyId,
    |                 'atomicOrganization',
    |                 OpenQDefinitions.InitOperation(0, initDataAtomic)
    |             )
    |         );
    |         require(successAtomic);
    | 
    |         address atomicBountyAddress = abi.decode(resultAtomic, (address));
    |         atomicBounty = AtomicBountyV1(payable(atomicBountyAddress));
    | 
    |         //************************* Mint Ongoing Bounty *************************/
    |         bytes memory initDataOngoing = abi.encode(
    |             address(0),
    |             10,
    |             true,
    |             address(0),
    |             100,
    |             true,
    |             true,
    |             true,
    |             '_issuerExternalUserId',
    |             'alternativeName',
    |             'alternativeLogo'
    |         );
    | 
    |         (bool successOngoing, bytes memory resultOngoing) = minter.proxy(
    |             address(openQ),
    |             abi.encodeWithSelector(
    |                 openQ.mintBounty.selector,
    |                 ongoingBountyId,
    |                 'OngoingOrganization',
    |                 OpenQDefinitions.InitOperation(1, initDataOngoing)
    |             )
    |         );
    |         require(successOngoing);
    | 
    |         address ongoingBountyAddress = abi.decode(resultOngoing, (address));
    |         ongoingBounty = OngoingBountyV1(payable(ongoingBountyAddress));
    | 
    |         //************************* Mint Tiered Percentage Bounty *************************/
    |         bytes memory initDataTieredPercentage = abi.encode(
    |             [100, 20, 30],
    |             true,
    |             address(0),
    |             1000,
    |             true,
    |             true,
    |             true,
    |             '_issuerExternalUserId',
    |             'alternativeName',
    |             'alternativeLogo'
    |         );
    | 
    |         (
    |             bool successTieredPercentage,
    |             bytes memory resultTieredPercentage
    |         ) = minter.proxy(
    |                 address(openQ),
    |                 abi.encodeWithSelector(
    |                     openQ.mintBounty.selector,
    |                     tieredBountyId,
    |                     'TieredOrganization',
    |                     OpenQDefinitions.InitOperation(2, initDataTieredPercentage)
    |                 )
    |             );
    |         require(successTieredPercentage);
    | 
    |         address tieredPercentageBountyAddress = abi.decode(
    |             resultTieredPercentage,
    |             (address)
    |         );
    |         tieredPercentageBounty = TieredPercentageBountyV1(
    |             payable(tieredPercentageBountyAddress)
    |         );
    | 
    |         //************************* Mint Tiered Fixed Bounty *************************/
    |         bytes memory initDataTieredFixed = abi.encode(
    |             [20, 10, 2],
    |             address(0),
    |             true,
    |             true,
    |             true,
    |             '_issuerExternalUserId',
    |             'alternativeName',
    |             'alternativeLogo'
    |         );
    | 
    |         (bool successTieredFixed, bytes memory resultTieredFixed) = minter
    |             .proxy(
    |                 address(openQ),
    |                 abi.encodeWithSelector(
    |                     openQ.mintBounty.selector,
    |                     tieredFixedBountyId,
    |                     'TieredFixedOrganization',
    |                     OpenQDefinitions.InitOperation(3, initDataTieredFixed)
    |                 )
    |             );
    |         require(successTieredFixed);
    | 
    |         address tieredFixedBountyAddress = abi.decode(
    |             resultTieredFixed,
    |             (address)
    |         );
    |         tieredFixedBounty = TieredFixedBountyV1(
    |             payable(tieredFixedBountyAddress)
    |         );
    | 
    |         bountiesDeployed = true;
    |     }
    | 
    |     // bind _number to [0, UPPER_BOUND) (0 inclusive, UPPER_BOUND exclusive)
    | 
    |     /// @notice Returns a number bound between [0, UPPER_BOUND) (0 inclusive, UPPER_BOUND exclusive) using _number as seed
    |     /// @dev Useful for scoping input to a certain range, e.g. for bounty types [0, 5)
    |     /// @param _number the seed coming from some random source
    |     /// @param UPPER_BOUND the OPEN (up to but not including) upper bound of the range
    |     /// @return A number between between [0, UPPER_BOUND)
*r  |     function bind(uint256 _number, uint256 UPPER_BOUND)
    |         public
    |         pure
*   |         returns (uint256)
    |     {
*r  |         return _number % UPPER_BOUND;
    |     }
    | 
    |     // assert that something never succeeds with assert(!success) on low-level call
    | }
    | 
    | // no codepath exists which can lower the bounty's balance of ERC20 or protocol tokens EXCEPT claimBounty, permissionClaimTieredBounty, or refundDeposit
    | 
    | // no codepath exists to change bounty.issuer() after being set in the initializer
    | 
    | // no codepath exists EXCEPT for owner that can call the setBountyFactory, setClaimManager, setDepositManager, transferOracle, or upgradeTo on OpenQ
    | // no codepath exists EXCEPT for owner that can call the setOpenQ, upgradeTo, transferOracle, or setKyc on ClaimManager
    | // no codepath exists EXCEPT for owner that can call setTokenWhitelist or upgradeTo on DepositManager
    | 
    | // no codepath exists EXCEPT for claimManager that can call claimNft, claimBalance, or close on AtomicBounty
    | // no codepath exists EXCEPT for claimManager that can call claimNft or claimOngoingPayout on OngoingBounty
    | // no codepath exists EXCEPT for claimManager that can call claimNft, claimTiered or closeCompetition on TieredPercentageBounty
    | // no codepath exists EXCEPT for claimManager that can call claimNft, claimTieredFixed or closeCompetition on TieredFixedBounty
    | 
    | // no codepath exists EXCEPT for oracle that can call claimBounty on ClaimManager
    | 
    | // no codepath exists EXCEPT for oracle that can call associateExternalIdToAddress on OpenQ
    | 
    | // no codepath exists EXCEPT for depositManager that can call receiveFunds, refundDeposit or extendDeposit on Bounty
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Fuzz/Users.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
r   | // Use this to get a constant User address
    | contract Users {
    |     function proxy(address target, bytes memory data)
    |         public
    |         returns (bool success, bytes memory returnData)
    |     {
    |         return target.call(data);
    |     }
    | 
    |     // (bool success, ) = user.proxy(address(openQ), abi.encodeWithSelector(openQ.mintBounty.selector, ...args));
    | 
    |     // for overloaded overrides
    |     // bytes4(keccak256("mint(address)"))
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/KYC/IKycValidity.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | /// @title IKycValidity
    | /// @author FlacoJones
    | /// @notice An interface for checking whether an address has a valid kycNFT token
    | /// @dev This interface integrates with KYC DAO (https://docs.kycdao.xyz/smartcontracts/evm/#adding-on-chain-kycnft-checks)
    | interface IKycValidity {
    |     /// @dev Check whether a given address has a valid kycNFT token
    |     /// @param _addr Address to check for kycNFT token
    |     /// @return valid Whether the address has a valid kycNFT token
    |     function hasValidToken(address _addr) external view returns (bool valid);
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Library/Errors.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | /// @title Errors
    | /// @author FlacoJones
    | /// @notice Revert message constants
    | library Errors {
    |     string constant BOUNTY_ALREADY_EXISTS = 'BOUNTY_ALREADY_EXISTS';
    |     string constant CALLER_NOT_ISSUER = 'CALLER_NOT_ISSUER';
    |     string constant CALLER_NOT_ISSUER_OR_ORACLE = 'CALLER_NOT_ISSUER_OR_ORACLE';
    |     string constant CONTRACT_NOT_CLOSED = 'CONTRACT_NOT_CLOSED';
    |     string constant CONTRACT_ALREADY_CLOSED = 'CONTRACT_ALREADY_CLOSED';
    |     string constant TOKEN_NOT_ACCEPTED = 'TOKEN_NOT_ACCEPTED';
    |     string constant NOT_A_COMPETITION_CONTRACT = 'NOT_A_COMPETITION_CONTRACT';
    |     string constant NOT_A_TIERED_FIXED_BOUNTY = 'NOT_A_TIERED_FIXED_BOUNTY';
    |     string constant TOKEN_TRANSFER_IN_OVERFLOW = 'TOKEN_TRANSFER_IN_OVERFLOW';
    |     string constant NOT_AN_ONGOING_CONTRACT = 'NOT_AN_ONGOING_CONTRACT';
    |     string constant NO_EMPTY_BOUNTY_ID = 'NO_EMPTY_BOUNTY_ID';
    |     string constant NO_EMPTY_ORGANIZATION = 'NO_EMPTY_ORGANIZATION';
    |     string constant ZERO_VOLUME_SENT = 'ZERO_VOLUME_SENT';
    |     string constant CONTRACT_IS_CLOSED = 'CONTRACT_IS_CLOSED';
    |     string constant TIER_ALREADY_CLAIMED = 'TIER_ALREADY_CLAIMED';
    |     string constant DEPOSIT_ALREADY_REFUNDED = 'DEPOSIT_ALREADY_REFUNDED';
    |     string constant CALLER_NOT_FUNDER = 'CALLER_NOT_FUNDER';
    |     string constant NOT_A_TIERED_BOUNTY = 'NOT_A_TIERED_BOUNTY';
    |     string constant NOT_A_FIXED_TIERED_BOUNTY = 'NOT_A_FIXED_TIERED_BOUNTY';
    |     string constant PREMATURE_REFUND_REQUEST = 'PREMATURE_REFUND_REQUEST';
    |     string constant NFT_DEPOSIT_LIMIT_REACHED = 'NFT_DEPOSIT_LIMIT_REACHED';
    |     string constant NO_ZERO_ADDRESS = 'NO_ZERO_ADDRESS';
    |     string constant CONTRACT_IS_NOT_CLAIMABLE = 'CONTRACT_IS_NOT_CLAIMABLE';
    |     string constant TOO_MANY_TOKEN_ADDRESSES = 'TOO_MANY_TOKEN_ADDRESSES';
    |     string constant NO_ASSOCIATED_ADDRESS = 'NO_ASSOCIATED_ADDRESS';
    |     string constant ADDRESS_LACKS_KYC = 'ADDRESS_LACKS_KYC';
    |     string constant TOKEN_NOT_ALREADY_WHITELISTED =
    |         'TOKEN_NOT_ALREADY_WHITELISTED';
    |     string constant TOKEN_ALREADY_WHITELISTED = 'TOKEN_ALREADY_WHITELISTED';
    |     string constant CLAIMANT_NOT_TIER_WINNER = 'CLAIMANT_NOT_TIER_WINNER';
    |     string constant INVOICE_NOT_COMPLETE = 'INVOICE_NOT_COMPLETE';
    |     string constant UNKNOWN_BOUNTY_TYPE = 'UNKNOWN_BOUNTY_TYPE';
    |     string constant SUPPORTING_DOCS_NOT_COMPLETE =
    |         'SUPPORTING_DOCS_NOT_COMPLETE';
    |     string constant EXPIRATION_NOT_GREATER_THAN_ZERO =
    |         'EXPIRATION_NOT_GREATER_THAN_ZERO';
    |     string constant PAYOUT_SCHEDULE_MUST_ADD_TO_100 =
    |         'PAYOUT_SCHEDULE_MUST_ADD_TO_100';
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Library/OpenQDefinitions.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | /// @title OpenQDefinitions
    | /// @author FlacoJones
    | /// @notice Constants for common operations
    | library OpenQDefinitions {
    |     /// @title OpenQDefinitions
    |     /// @author FlacoJones
    |     /// @param operationType The bounty type
    |     /// @param data ABI encoded data used to initialize the bounty
    |     struct InitOperation {
    |         uint32 operationType;
    |         bytes data;
    |     }
    | 
    |     /// @notice Bounty types
    |     uint32 internal constant ATOMIC = 0;
    |     uint32 internal constant ONGOING = 1;
    |     uint32 internal constant TIERED_PERCENTAGE = 2;
    |     uint32 internal constant TIERED_FIXED = 3;
    | 
    |     uint32 internal constant OPEN = 0;
    |     uint32 internal constant CLOSED = 1;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Mocks/MockDai.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity 0.8.17;
    | 
    | // Third party
    | import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
    | 
    | contract MockDai is ERC20 {
    |     address public admin;
    | 
    |     constructor() ERC20('Mock DAI', 'mDAI') {
    |         _mint(msg.sender, 10000 * 10**18);
    |         admin = msg.sender;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Mocks/MockKyc.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../KYC/IKycValidity.sol';
    | 
    | contract MockKyc is IKycValidity {
    |     bool public isValid;
    | 
    |     function setIsValid(bool _isValid) external {
    |         isValid = _isValid;
    |     }
    | 
    |     function hasValidToken(address) external view returns (bool valid) {
    |         return isValid;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Mocks/MockLink.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity 0.8.17;
    | 
    | // Third party
    | import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
    | 
    | contract MockLink is ERC20 {
    |     address public admin;
    | 
    |     constructor() ERC20('Mock Link', 'mLINK') {
    |         _mint(msg.sender, 10000 * 10**18);
    |         admin = msg.sender;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Mocks/MockNft.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity 0.8.17;
    | 
    | import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
    | import '@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol';
    | import '@openzeppelin/contracts/access/Ownable.sol';
    | import '@openzeppelin/contracts/utils/Counters.sol';
    | 
    | contract MockNft is ERC721, ERC721URIStorage, Ownable {
    |     using Counters for Counters.Counter;
    | 
    |     Counters.Counter private _tokenIdCounter;
    | 
    |     constructor() ERC721('MockNft', 'MNFT') {}
    | 
    |     string uri =
    |         'https://darkhorse.infura-ipfs.io/ipfs/Qmdpxsr7Ynhf6pF6Y5rke4fWNEZc3geWupLiG2uKC3R8RT';
    | 
    |     function safeMint(address to) external onlyOwner {
    |         uint256 tokenId = _tokenIdCounter.current();
    |         _tokenIdCounter.increment();
    |         _safeMint(to, tokenId);
    |         _setTokenURI(tokenId, uri);
    |     }
    | 
    |     // The following functions are overrides required by Solidity.
    | 
    |     function _burn(uint256 tokenId)
    |         internal
    |         override(ERC721, ERC721URIStorage)
    |     {
    |         super._burn(tokenId);
    |     }
    | 
    |     function tokenURI(uint256 tokenId)
    |         public
    |         view
    |         override(ERC721, ERC721URIStorage)
    |         returns (string memory)
    |     {
    |         return super.tokenURI(tokenId);
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Mocks/TestToken.sol
    | // SPDX-License-Identifier: AGPLv3
    | pragma solidity 0.8.17;
    | 
    | import {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';
    | 
    | /// @title Test token contract
    | ///  @author Superfluid
    | /// @notice Test ERC20 token that allows any one mint new tokens.
    | contract TestToken is ERC20 {
    |     uint256 public constant MINT_LIMIT = 1e12 ether;
    |     uint8 private _decimals;
    | 
    |     constructor(
    |         string memory name,
    |         string memory symbol,
    |         uint8 initDecimals
    |     ) ERC20(name, symbol) {
    |         _decimals = initDecimals;
    |     }
    | 
    |     function mint(address account, uint256 amount) external returns (bool) {
    |         assert(amount <= MINT_LIMIT); // no revert msg for you, bad boy
    |         ERC20._mint(account, amount);
    |         return true;
    |     }
    | 
    |     function decimals() public view override returns (uint8) {
    |         return _decimals;
    |     }
    | 
    |     // Shuts up slither about making decimals() external :-)
    |     function getDecimals() external view returns (uint8) {
    |         return decimals();
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Mocks/TransferFeeToken.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity 0.8.17;
    | 
    | // Third party
    | import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
    | 
    | contract TokenFeeToken is ERC20 {
    |     address public admin;
    | 
    |     constructor() ERC20('Fee Token', 'FEE') {
    |         _mint(msg.sender, 10000 * 10**18);
    |         admin = msg.sender;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/OnlyOpenQ/OnlyOpenQ.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';
    | 
    | /// @title OnlyOpenQ
    | /// @author FlacoJones
    | /// @notice Ownable-style contract to restrict access for method calls exclusively to the OpenQProxy address
    | abstract contract OnlyOpenQ is ContextUpgradeable {
    |     /// @notice OpenQProxy address
    |     address private _openQ;
    | 
    |     /// @notice Initializes contract with OpenQProxy address
    |     /// @param _initalOpenQ The OpenQProxy address
    |     function __OnlyOpenQ_init(address _initalOpenQ) internal {
    |         _openQ = _initalOpenQ;
    |     }
    | 
    |     /// @notice Getter for the current OpenQProxy address
    |     function openQ() public view returns (address) {
    |         return _openQ;
    |     }
    | 
    |     /// @notice Modifier to restrict access of methods to OpenQProxy address
    |     modifier onlyOpenQ() {
    |         require(_msgSender() == _openQ, 'Method is only callable by OpenQ');
    |         _;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/OpenQ/Implementations/OpenQV1.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '../Storage/OpenQStorage.sol';
    | 
    | /// @title OpenQV1
    | /// @author FlacoJones
    | /// @notice Main administrative contract for all bounty operations
*   | /// @dev Do not add any new storage variables here. Put them in a OpenQStorageV# and release new implementation
    | contract OpenQV1 is OpenQStorageV1 {
    |     constructor() {}
    | 
    |     /// @notice Initializes the OpenQ implementation with necessary storage variables like owner
    |     function initialize() external initializer onlyProxy {
    |         __Ownable_init();
    |         __UUPSUpgradeable_init();
    |         __ReentrancyGuard_init();
    |     }
    | 
    |     /// @notice Mints a new bounty BeaconProxy using BountyFactory
    |     /// @param _bountyId A unique string to identify a bounty
    |     /// @param _organization The ID of the organization which owns the bounty
    |     /// @param _initOperation The ABI encoded data determining the type of bounty being initialized and associated data
    |     /// @dev see IBountyCore.initialize.(_operation) for _operation ABI encoding schema
    |     /// @return bountyAddress The address of the newly minted bounty
    |     function mintBounty(
    |         string calldata _bountyId,
    |         string calldata _organization,
    |         OpenQDefinitions.InitOperation memory _initOperation
    |     ) external nonReentrant onlyProxy returns (address) {
    |         require(
    |             bountyIdToAddress[_bountyId] == address(0),
    |             Errors.BOUNTY_ALREADY_EXISTS
    |         );
    | 
    |         address bountyAddress = bountyFactory.mintBounty(
    |             _bountyId,
    |             msg.sender,
    |             _organization,
    |             claimManager,
    |             depositManager,
    |             _initOperation
    |         );
    | 
    |         bountyIdToAddress[_bountyId] = bountyAddress;
    | 
    |         emit BountyCreated(
    |             _bountyId,
    |             _organization,
    |             msg.sender,
    |             bountyAddress,
    |             block.timestamp,
    |             bountyType(_bountyId),
    |             _initOperation.data,
    |             VERSION_1
    |         );
    | 
    |         return bountyAddress;
    |     }
    | 
    |     /// @notice Sets the BountyFactory
    |     /// @param _bountyFactory The BountyFactory address
    |     function setBountyFactory(address _bountyFactory)
    |         external
    |         onlyProxy
    |         onlyOwner
    |     {
    |         bountyFactory = BountyFactory(_bountyFactory);
    |     }
    | 
    |     /// @notice Sets ClaimManager proxy address
    |     /// @param _claimManager The ClaimManager address
    |     function setClaimManager(address _claimManager)
    |         external
    |         onlyProxy
    |         onlyOwner
    |     {
    |         claimManager = _claimManager;
    |     }
    | 
    |     /// @notice Sets DepositManager proxy address
    |     /// @param _depositManager The DepositManager address
    |     function setDepositManager(address _depositManager)
    |         external
    |         onlyProxy
    |         onlyOwner
    |     {
    |         depositManager = _depositManager;
    |     }
    | 
    |     /// @notice Sets a winner for a particular tier
    |     /// @param _bountyId The bounty id
    |     /// @param _tier The tier they won
    |     /// @param _winner The external UUID (e.g. an OpenQ User UUID) that won this tier
    |     /// @dev Only callable by the bounty admin (AKA the minter of the bounty)
    |     function setTierWinner(
    |         string calldata _bountyId,
    |         uint256 _tier,
    |         string calldata _winner
    |     ) external {
    |         IBounty bounty = getBounty(_bountyId);
    |         require(msg.sender == bounty.issuer(), Errors.CALLER_NOT_ISSUER);
    |         bounty.setTierWinner(_winner, _tier);
    | 
    |         emit TierWinnerSelected(
    |             address(bounty),
    |             bounty.getTierWinners(),
    |             new bytes(0),
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Sets fundingGoal for bounty with id _bountyId
    |     /// @param _bountyId The id to update
    |     /// @param _fundingGoalToken The token address to be used for the funding goal
    |     /// @param _fundingGoalVolume The volume of token to be used for the funding goal
    |     function setFundingGoal(
    |         string calldata _bountyId,
    |         address _fundingGoalToken,
    |         uint256 _fundingGoalVolume
    |     ) external onlyProxy {
    |         IBounty bounty = getBounty(_bountyId);
    | 
    |         require(msg.sender == bounty.issuer(), Errors.CALLER_NOT_ISSUER);
    | 
    |         bounty.setFundingGoal(_fundingGoalToken, _fundingGoalVolume);
    | 
    |         emit FundingGoalSet(
    |             address(bounty),
    |             _fundingGoalToken,
    |             _fundingGoalVolume,
    |             bounty.bountyType(),
    |             new bytes(0),
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Sets kycRequired on bounty with id _bountyId
    |     /// @param _bountyId The id to update
    |     /// @param _kycRequired Whether or not KYC is required for a bounty
    |     function setKycRequired(string calldata _bountyId, bool _kycRequired)
    |         external
    |         onlyProxy
    |     {
    |         IBounty bounty = getBounty(_bountyId);
    | 
    |         require(msg.sender == bounty.issuer(), Errors.CALLER_NOT_ISSUER);
    | 
    |         bounty.setKycRequired(_kycRequired);
    | 
    |         emit KYCRequiredSet(
    |             address(bounty),
    |             _kycRequired,
    |             bounty.bountyType(),
    |             new bytes(0),
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Sets invoiceRequired on bounty with id _bountyId
    |     /// @param _bountyId The id to update
    |     /// @param _invoiceRequired Whether or not the bounty should be set as invoiceRequired
    |     function setInvoiceRequired(
    |         string calldata _bountyId,
    |         bool _invoiceRequired
    |     ) external onlyProxy {
    |         IBounty bounty = getBounty(_bountyId);
    | 
    |         require(msg.sender == bounty.issuer(), Errors.CALLER_NOT_ISSUER);
    | 
    |         bounty.setInvoiceRequired(_invoiceRequired);
    | 
    |         emit InvoiceRequiredSet(
    |             address(bounty),
    |             _invoiceRequired,
    |             bounty.bountyType(),
    |             new bytes(0),
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Sets whether or not supporting documents will be required to claim a bounty
    |     /// @param _bountyId The id to update
    |     /// @param _supportingDocumentsRequired Whether or not supporting documents are required to claim this bounty
    |     function setSupportingDocumentsRequired(
    |         string calldata _bountyId,
    |         bool _supportingDocumentsRequired
    |     ) external onlyProxy {
    |         IBounty bounty = getBounty(_bountyId);
    | 
    |         require(msg.sender == bounty.issuer(), Errors.CALLER_NOT_ISSUER);
    | 
    |         bounty.setSupportingDocumentsRequired(_supportingDocumentsRequired);
    | 
    |         emit SupportingDocumentsRequiredSet(
    |             address(bounty),
    |             _supportingDocumentsRequired,
    |             bounty.bountyType(),
    |             new bytes(0),
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Sets invoiceComplete on bounty with id _bountyId
    |     /// @param _bountyId The id to update
    |     /// @param _data ABI encoded data (A simple bool for AtomicContract, a (string, bool) of claimId for Ongoing, and a (uint256, bool) for TieredBounty to specify the tier it was completed for)
    |     function setInvoiceComplete(string calldata _bountyId, bytes calldata _data)
    |         external
    |         onlyProxy
    |     {
    |         IBounty bounty = getBounty(_bountyId);
    | 
    |         require(
    |             msg.sender == bounty.issuer() || msg.sender == _oracle,
    |             Errors.CALLER_NOT_ISSUER_OR_ORACLE
    |         );
    | 
    |         bounty.setInvoiceComplete(_data);
    | 
    |         emit InvoiceCompleteSet(
    |             address(bounty),
    |             bounty.bountyType(),
    |             bounty.getInvoiceComplete(),
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Sets supportingDocumentsComplete on bounty with id _bountyId
    |     /// @param _bountyId The id to update
    |     /// @param _data ABI encoded data (A simple bool for AtomicContract, a (string, bool) of claimId for Ongoing, and a (uint256, bool) for TieredBounty to specify the tier it was completed for)
    |     function setSupportingDocumentsComplete(
    |         string calldata _bountyId,
    |         bytes calldata _data
    |     ) external onlyProxy {
    |         IBounty bounty = getBounty(_bountyId);
    | 
    |         require(
    |             msg.sender == bounty.issuer() || msg.sender == _oracle,
    |             Errors.CALLER_NOT_ISSUER_OR_ORACLE
    |         );
    | 
    |         bounty.setSupportingDocumentsComplete(_data);
    | 
    |         emit SupportingDocumentsCompleteSet(
    |             address(bounty),
    |             bounty.bountyType(),
    |             bounty.getSupportingDocumentsComplete(),
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Sets payout token address and volume on bounty with id _bountyId
    |     /// @param _bountyId The id to update
    |     /// @param _payoutToken The token address to be used for the payout
    |     /// @param _payoutVolume The volume of token to be used for the payout
    |     function setPayout(
    |         string calldata _bountyId,
    |         address _payoutToken,
    |         uint256 _payoutVolume
    |     ) external onlyProxy {
    |         IBounty bounty = getBounty(_bountyId);
    | 
    |         require(msg.sender == bounty.issuer(), Errors.CALLER_NOT_ISSUER);
    | 
    |         bounty.setPayout(_payoutToken, _payoutVolume);
    | 
    |         emit PayoutSet(
    |             address(bounty),
    |             _payoutToken,
    |             _payoutVolume,
    |             bounty.bountyType(),
    |             new bytes(0),
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Sets payout volume array on percentage tiered bounty with id _bountyId
    |     /// @dev There is no tokenAddress needed here - payouts on percentage tiered bounties is a percentage of whatever is deposited on the contract
    |     /// @param _bountyId The bounty to update
    |     /// @param _payoutSchedule An array of payout volumes for each tier
    |     function setPayoutSchedule(
    |         string calldata _bountyId,
    |         uint256[] calldata _payoutSchedule
    |     ) external onlyProxy {
    |         IBounty bounty = getBounty(_bountyId);
    | 
    |         require(msg.sender == bounty.issuer(), Errors.CALLER_NOT_ISSUER);
    | 
    |         bounty.setPayoutSchedule(_payoutSchedule);
    | 
    |         emit PayoutScheduleSet(
    |             address(bounty),
    |             address(0),
    |             _payoutSchedule,
    |             bounty.bountyType(),
    |             new bytes(0),
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Sets payout volume array on fixed tiered bounty with id _bountyId
    |     /// @param _bountyId The bounty to update
    |     /// @param _payoutSchedule An array of payout volumes for each tier
    |     /// @param _payoutTokenAddress The address of the token to be used for the payout
    |     function setPayoutScheduleFixed(
    |         string calldata _bountyId,
    |         uint256[] calldata _payoutSchedule,
    |         address _payoutTokenAddress
    |     ) external onlyProxy {
    |         IBounty bounty = getBounty(_bountyId);
    | 
    |         require(msg.sender == bounty.issuer(), Errors.CALLER_NOT_ISSUER);
    | 
    |         bounty.setPayoutScheduleFixed(_payoutSchedule, _payoutTokenAddress);
    | 
    |         emit PayoutScheduleSet(
    |             address(bounty),
    |             _payoutTokenAddress,
    |             _payoutSchedule,
    |             bounty.bountyType(),
    |             new bytes(0),
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Closes and ongoing bounty
    |     /// @param _bountyId The ongoing bounty to close
    |     function closeOngoing(string calldata _bountyId) external {
    |         require(bountyIsOpen(_bountyId), Errors.CONTRACT_ALREADY_CLOSED);
    |         require(
    |             bountyType(_bountyId) == OpenQDefinitions.ONGOING,
    |             Errors.NOT_AN_ONGOING_CONTRACT
    |         );
    | 
    |         IBounty bounty = IBounty(payable(bountyIdToAddress[_bountyId]));
    | 
    |         require(msg.sender == bounty.issuer(), Errors.CALLER_NOT_ISSUER);
    | 
    |         bounty.closeOngoing(msg.sender);
    | 
    |         emit BountyClosed(
    |             _bountyId,
    |             bountyIdToAddress[_bountyId],
    |             bounty.organization(),
    |             address(0),
    |             block.timestamp,
    |             bounty.bountyType(),
    |             new bytes(0),
    |             VERSION_1
    |         );
    |     }
    | 
    |     /// @notice Checks if bounty associated with _bountyId is open
    |     /// @param _bountyId The bounty id
    |     /// @return True if _bountyId is associated with an open bounty, false otherwise
    |     function bountyIsOpen(string calldata _bountyId)
    |         public
    |         view
    |         returns (bool)
    |     {
    |         IBounty bounty = getBounty(_bountyId);
    |         bool isOpen = bounty.status() == OpenQDefinitions.OPEN;
    |         return isOpen;
    |     }
    | 
    |     /// @notice Returns the bountyType of the bounty (Single(0), Ongoing(1), Tiered(2), or Tiered Fixed(3))
    |     /// @param _bountyId The bounty id
    |     /// @return bountyType - See OpenQDefinitions.sol for values
    |     function bountyType(string calldata _bountyId)
    |         public
    |         view
    |         returns (uint256)
    |     {
    |         IBounty bounty = getBounty(_bountyId);
    |         uint256 _bountyType = bounty.bountyType();
    |         return _bountyType;
    |     }
    | 
    |     /// @notice Retrieves bountyId from a bounty's address
    |     /// @param _bountyAddress The bounty address
    |     /// @return string The bounty id associated with _bountyAddress
*   |     function bountyAddressToBountyId(address _bountyAddress)
    |         external
    |         view
    |         returns (string memory)
    |     {
    |         IBounty bounty = IBounty(payable(_bountyAddress));
    |         return bounty.bountyId();
    |     }
    | 
    |     /// @notice Determines whether or not a tier is claimed on a percentage tiered or fixed tiered bounty
    |     /// @param _bountyId The bounty id
    |     /// @param _tier The tier to check
    |     /// @return True if claimed, false otherwise
    |     function tierClaimed(string calldata _bountyId, uint256 _tier)
    |         external
    |         view
    |         returns (bool)
    |     {
    |         IBounty bounty = getBounty(_bountyId);
    |         bool _tierClaimed = bounty.tierClaimed(_tier);
    |         return _tierClaimed;
    |     }
    | 
    |     /// @notice Determines whether or not an ongoing bounty or tiered bounty have enough funds to cover payouts
    |     /// @param _bountyId The bounty id
    |     /// @return True if solvent, false otherwise
    |     function solvent(string calldata _bountyId) external view returns (bool) {
    |         IBounty bounty = getBounty(_bountyId);
    | 
    |         uint256 balance = bounty.getTokenBalance(bounty.payoutTokenAddress());
    |         return balance >= bounty.payoutVolume();
    |     }
    | 
    |     /// @notice Returns an IBounty ABI wrapped arround given bounty address
    |     /// @param _bountyId The bounty id
    |     /// @return An IBounty upon which any methods in IBounty can be called
    |     function getBounty(string calldata _bountyId)
    |         internal
    |         view
    |         returns (IBounty)
    |     {
    |         address bountyAddress = bountyIdToAddress[_bountyId];
    |         IBounty bounty = IBounty(bountyAddress);
    |         return bounty;
    |     }
    | 
    |     /// @notice Determines whether or not a given submission by claimant has already been used for a claim
    |     /// @param _bountyId The bounty id
    |     /// @param _claimant The external user id to check
    |     /// @param _claimantAsset The external id of the claimant's asset to check
    |     /// @return True if claimed, false otherwise
    |     function ongoingClaimed(
    |         string calldata _bountyId,
    |         string calldata _claimant,
    |         string calldata _claimantAsset
    |     ) external view returns (bool) {
    |         IBounty bounty = getBounty(_bountyId);
    |         bytes32 claimId = keccak256(abi.encode(_claimant, _claimantAsset));
    |         bool _ongoingClaimed = bounty.claimId(claimId);
    |         return _ongoingClaimed;
    |     }
    | 
    |     /// @notice Override for UUPSUpgradeable._authorizeUpgrade(address newImplementation) to enforce onlyOwner upgrades
    |     function _authorizeUpgrade(address) internal override onlyOwner {}
    | 
    |     /// @notice Override for ERC1967Upgrade._getImplementation() to expose implementation
    |     /// @return address Implementation address associated with OpenQProxy
    |     function getImplementation() external view returns (address) {
    |         return _getImplementation();
    |     }
    | 
    |     /// @notice Exposes internal method Oraclize._transferOracle(address) restricted to onlyOwner called via proxy
    |     /// @param _newOracle The new oracle address
    |     function transferOracle(address _newOracle) external onlyProxy onlyOwner {
    |         require(_newOracle != address(0), Errors.NO_ZERO_ADDRESS);
    |         _transferOracle(_newOracle);
    |     }
    | 
    |     /// @notice Establishes a one-to-one mapping between an external user id and an address
    |     /// @param _externalUserId The external user id (e.g. Github user id) to associate
    |     /// @param _associatedAddress The address to associate to _externalUserId
    |     /// @dev It is important that this nulls out the previous addres<=>uuid association
    |     function associateExternalIdToAddress(
    |         string calldata _externalUserId,
    |         address _associatedAddress
    |     ) external onlyOracle {
    |         // Clear previous addres<=>off-chain identity associations
    |         string memory formerExternalUserId = addressToExternalUserId[
    |             _associatedAddress
    |         ];
    |         address formerAddress = externalUserIdToAddress[_externalUserId];
    | 
    |         externalUserIdToAddress[formerExternalUserId] = address(0);
    |         addressToExternalUserId[formerAddress] = '';
    | 
    |         externalUserIdToAddress[_externalUserId] = _associatedAddress;
    |         addressToExternalUserId[_associatedAddress] = _externalUserId;
    | 
    |         emit ExternalUserIdAssociatedWithAddress(
    |             _externalUserId,
    |             _associatedAddress,
    |             formerExternalUserId,
    |             formerAddress,
    |             new bytes(0),
    |             VERSION_1
    |         );
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/OpenQ/Interfaces/IOpenQ.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | /// @title IOpenQ
    | /// @author FlacoJones
    | /// @notice Interface declaring OpenQ events and methods used by other contracts
    | interface IOpenQ {
    |     function externalUserIdToAddress(string calldata)
    |         external
    |         returns (address);
    | 
    |     function addressToExternalUserId(address) external returns (string memory);
    | 
    |     event TierClaimed(
    |         address bountyAddress,
    |         address claimant,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event BountyCreated(
    |         string bountyId,
    |         string organization,
    |         address issuerAddress,
    |         address bountyAddress,
    |         uint256 bountyMintTime,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event FundingGoalSet(
    |         address bountyAddress,
    |         address fundingGoalTokenAddress,
    |         uint256 fundingGoalVolume,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event PayoutSet(
    |         address bountyAddress,
    |         address payoutTokenAddress,
    |         uint256 payoutTokenVolume,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event PayoutScheduleSet(
    |         address bountyAddress,
    |         address payoutTokenAddress,
    |         uint256[] payoutSchedule,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event KYCRequiredSet(
    |         address bountyAddress,
    |         bool kycRequired,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event InvoiceRequiredSet(
    |         address bountyAddress,
    |         bool invoiceRequired,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event SupportingDocumentsRequiredSet(
    |         address bountyAddress,
    |         bool supportingDocuments,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event InvoiceCompleteSet(
    |         address bountyAddress,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event SupportingDocumentsCompleteSet(
    |         address bountyAddress,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event BountyClosed(
    |         string bountyId,
    |         address bountyAddress,
    |         string organization,
    |         address closer,
    |         uint256 bountyClosedTime,
    |         uint256 bountyType,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event TierWinnerSelected(
    |         address bountyAddress,
    |         string[] tierWinners,
    |         bytes data,
    |         uint256 version
    |     );
    | 
    |     event ExternalUserIdAssociatedWithAddress(
    |         string newExternalUserId,
    |         address newAddress,
    |         string formerExternalUserId,
    |         address formerAddress,
    |         bytes data,
    |         uint256 version
    |     );
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/OpenQ/Proxy/OpenQProxy.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol';
    | 
    | /// @title OpenQProxy
    | /// @author FlacoJones
*r  | /// @notice ERC1967Proxy through which all OpenQ transactions pass through
    | contract OpenQProxy is ERC1967Proxy {
    |     /// @notice ERC1967Proxy constructor
    |     /// @param _logic The deployed implementation contract to send all delegatecall to
    |     /// @param _data Additional data to pass to initialize method (an empty byte array in the case of OpenQ)
    |     constructor(address _logic, bytes memory _data)
    |         payable
    |         ERC1967Proxy(_logic, _data)
    |     {}
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/OpenQ/Storage/OpenQStorage.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';
    | import '@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol';
    | import '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';
    | 
    | import '../../BountyFactory/BountyFactory.sol';
    | import '../../Library/OpenQDefinitions.sol';
    | import '../../Library/Errors.sol';
    | import '../../OpenQ/Interfaces/IOpenQ.sol';
    | import '../../Oracle/Oraclize.sol';
    | 
    | import '../../Bounty/Interfaces/IBounty.sol';
    | 
    | /// @title OpenQStorageV1
    | /// @author FlacoJones
    | /// @notice Backwards compatible, append-only chain of storage contracts inherited by OpenQ implementations
    | /// @dev See (https://github.com/compound-finance/compound-protocol/blob/master/contracts/ComptrollerStorage.sol) for example
    | /// @dev See (https://forum.openzeppelin.com/t/to-inherit-version1-to-version2-or-to-copy-code-inheritance-order-from-version1-to-version2/28069) for explanation
    | abstract contract OpenQStorageV1 is
    |     IOpenQ,
    |     OwnableUpgradeable,
    |     UUPSUpgradeable,
    |     ReentrancyGuardUpgradeable,
    |     Oraclize
    | {
*   |     uint256 public constant VERSION_1 = 1;
    |     BountyFactory public bountyFactory;
    |     address public claimManager;
    |     address public depositManager;
    |     mapping(string => address) public bountyIdToAddress;
    |     mapping(string => address) public externalUserIdToAddress;
    |     mapping(address => string) public addressToExternalUserId;
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/Oracle/Oraclize.sol
    | // SPDX-License-Identifier: BUSL-1.1
    | pragma solidity 0.8.17;
    | 
    | import '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';
    | 
    | /// @title Oraclize
    | /// @author FlacoJones
    | /// @notice Restricts access for method calls to oracle address
    | abstract contract Oraclize is ContextUpgradeable {
    |     /// @notice Oracle address
    |     address internal _oracle;
    | 
    |     event OracleTransferred(
    |         address indexed previousOracle,
    |         address indexed newOracle
    |     );
    | 
    |     /// @notice Initializes child contract with _initialOracle. Only callabel during initialization.
    |     /// @param _initialOracle The initial oracle address
    |     function __Oraclize_init(address _initialOracle) internal onlyInitializing {
    |         _oracle = _initialOracle;
    |     }
    | 
    |     /// @notice Transfers oracle of the contract to a new account (`newOracle`).
    |     function _transferOracle(address newOracle) internal virtual {
    |         address oldOracle = _oracle;
    |         _oracle = newOracle;
    |         emit OracleTransferred(oldOracle, newOracle);
    |     }
    | 
    |     /// @notice Returns the address of _oracle
    |     function oracle() external view virtual returns (address) {
    |         return _oracle;
    |     }
    | 
    |     /// @notice Modifier to restrict access of methods to _oracle address
    |     modifier onlyOracle() {
    |         require(
    |             _oracle == _msgSender(),
    |             'Oraclize: caller is not the current OpenQ Oracle'
    |         );
    |         _;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/TokenWhitelist/OpenQTokenWhitelist.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity 0.8.17;
    | 
    | import './TokenWhitelist.sol';
    | 
    | /// @title OpenQTokenWhitelist
    | /// @author FlacoJones
    | /// @notice OpenQTokenWhitelist provides the list of verified token addresses
r   | /// @dev Whitelisting and token address limit is implemented primarily as a means of preventing out-of-gas exceptions when looping over funded addresses for payouts
    | contract OpenQTokenWhitelist is TokenWhitelist {
    |     /// @notice Initializes OpenQTokenWhitelist with maximum token address limit to prevent out-of-gas errors
    |     /// @param _tokenAddressLimit Maximum number of token addresses allowed
    |     constructor(uint256 _tokenAddressLimit) TokenWhitelist() {
    |         TOKEN_ADDRESS_LIMIT = _tokenAddressLimit;
    |     }
    | }
    | 

/Users/alo/OpenQ-Fullstack/OpenQ-Contracts/contracts/TokenWhitelist/TokenWhitelist.sol
    | // SPDX-License-Identifier: MIT
    | pragma solidity 0.8.17;
    | 
    | import '@openzeppelin/contracts/access/Ownable.sol';
    | import '../Library/Errors.sol';
    | 
    | /// @title TokenWhitelist
    | /// @author FlacoJones
    | /// @notice Base contract for token whitelists
    | /// @dev Whitelisting and token address limit is implemented primarily as a means of preventing out-of-gas exceptions when looping over funded addresses for payouts
    | abstract contract TokenWhitelist is Ownable {
    |     uint256 public TOKEN_ADDRESS_LIMIT;
    |     uint256 public tokenCount;
    |     mapping(address => bool) public whitelist;
    | 
    |     /// @notice Determines if a tokenAddress is whitelisted
    |     /// @param _tokenAddress The token address on which to check whitelisting status
    |     /// @return bool Whether or not tokenAddress is whitelisted
    |     function isWhitelisted(address _tokenAddress) external view returns (bool) {
    |         return whitelist[_tokenAddress];
    |     }
    | 
    |     /// @notice Adds tokenAddress to the whitelist
    |     /// @param _tokenAddress The token address to add to the whitelist
    |     function addToken(address _tokenAddress) external onlyOwner {
    |         require(
    |             !this.isWhitelisted(_tokenAddress),
    |             Errors.TOKEN_ALREADY_WHITELISTED
    |         );
    |         whitelist[_tokenAddress] = true;
    |         tokenCount++;
    |     }
    | 
    |     /// @notice Removes tokenAddress to the whitelist
    |     /// @param _tokenAddress The token address to remove from the whitelist
    |     function removeToken(address _tokenAddress) external onlyOwner {
    |         require(
    |             this.isWhitelisted(_tokenAddress),
    |             Errors.TOKEN_NOT_ALREADY_WHITELISTED
    |         );
    |         whitelist[_tokenAddress] = false;
    |         tokenCount--;
    |     }
    | 
    |     /// @notice Updates the tokenAddressLimit
    |     /// @param _newTokenAddressLimit The new value for TOKEN_ADDRESS_LIMIT
    |     function setTokenAddressLimit(uint256 _newTokenAddressLimit)
    |         external
    |         onlyOwner
    |     {
    |         TOKEN_ADDRESS_LIMIT = _newTokenAddressLimit;
    |     }
    | }
    | 
